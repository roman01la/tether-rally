<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
		<link rel="shortcut icon" href="/icon_xs.png" />
		<title>Tether Rally</title>
		<style>
			:root {
				--color-success: #40916c;
				--color-success-light: #52b788;
				--color-success-dark: #2d6a4f;
				--color-error: #e63946;
				--color-warning: #e85d04;
				--color-turbo: #ff8c00;
				--color-turbo-border: #ffa500;
				--color-panel-bg: rgba(30, 30, 50, 0.7);
				--color-panel-hover: rgba(50, 50, 80, 0.8);
				--color-border: rgba(100, 100, 140, 0.5);
				--color-border-light: rgba(150, 150, 200, 0.5);
				--color-text-muted: rgba(255, 255, 255, 0.7);
				--color-bg-dark: #1a1a2e;
				--color-bg-darker: #16213e;
				--color-accent: #5a5a8a;
				--color-accent-light: #7a7aba;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
			body {
				font-family: -apple-system, BlinkMacSystemFont, sans-serif;
				background: #000;
				color: #eee;
				height: 100vh;
				width: 100vw;
				user-select: none;
			}
			body.race-mode {
				overflow: hidden;
				touch-action: none;
			}
			/* Login screen */
			#login-screen {
				position: absolute;
				inset: 0;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: flex-start;
				gap: 20px;
				background: var(--color-bg-dark);
				z-index: 100;
				overflow-y: auto;
				padding: 20px;
			}
			#login-screen.hidden {
				display: none;
			}
			#login-screen h1 {
				font-size: 24px;
				font-weight: 300;
				color: #888;
			}
			#login-screen input {
				padding: 12px 20px;
				font-size: 16px;
				border: 2px solid #3a3a5a;
				border-radius: 10px;
				background: var(--color-bg-darker);
				color: #eee;
				width: 280px;
				text-align: center;
				font-family: monospace;
			}
			#login-screen input:focus {
				outline: none;
				border-color: #6a6a9a;
			}
			#login-screen button {
				padding: 12px 40px;
				font-size: 16px;
				border: none;
				border-radius: 10px;
				background: var(--color-success-dark);
				color: #eee;
				cursor: pointer;
				font-weight: 600;
			}
			#login-screen button:hover {
				background: var(--color-success);
			}
			#login-screen button:disabled {
				background: #3a3a5a;
				cursor: not-allowed;
			}
			#login-error {
				color: var(--color-error);
				font-size: 14px;
				min-height: 20px;
			}
			#device-status {
				font-size: 12px;
				color: #666;
				margin-top: -10px;
			}
			#device-status.online {
				color: var(--color-success);
			}
			.info-section {
				max-width: 400px;
				padding: 20px 20px 12px;
				background: var(--color-bg-darker);
				border-radius: 12px;
				text-align: left;
			}
			.info-section h2 {
				font-size: 16px;
				font-weight: 600;
				color: #eee;
				margin-bottom: 12px;
			}
			.info-section p {
				font-size: 14px;
				color: #888;
				line-height: 1.5;
				margin-bottom: 12px;
			}
			.info-section ul {
				margin: 0 0 12px 20px;
				font-size: 14px;
				color: #888;
				line-height: 1.6;
			}
			.info-section li {
				margin-bottom: 4px;
			}
			.info-section strong {
				color: #aaa;
			}
			.info-section .highlight {
				color: var(--color-success);
			}

			/* Control screen - racing game style */
			#control-screen {
				position: absolute;
				inset: 0;
				display: none;
			}
			#control-screen.active {
				display: block;
			}

			/* Video background */
			#video-container {
				position: absolute;
				inset: 0;
				background: #111;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#video-container video {
				position: absolute;
				width: 100%;
				height: 100%;
				object-fit: cover;
			}
			#video-placeholder {
				color: #555;
				font-size: 14px;
				text-transform: uppercase;
				letter-spacing: 3px;
				z-index: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 15px;
			}
			#video-placeholder .spinner {
				width: 30px;
				height: 30px;
				border: 3px solid rgba(255, 255, 255, 0.1);
				border-top-color: rgba(255, 255, 255, 0.5);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			#video-placeholder .spinner.hidden {
				display: none;
			}

			/* Controls disabled overlay */
			.control-zone.disabled {
				opacity: 0.3;
				pointer-events: none;
			}

			/* HUD overlay */
			#hud {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				padding: 15px;
				gap: 20px;
				background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), transparent);
				pointer-events: none;
			}
			#status {
				padding: 6px 14px;
				border-radius: 20px;
				font-size: 12px;
				font-weight: 600;
			}
			#status.connected {
				background: rgba(45, 106, 79, 0.9);
			}
			#status.disconnected {
				background: rgba(157, 2, 8, 0.9);
			}
			#status.connecting {
				background: rgba(232, 93, 4, 0.9);
			}

			/* Shared control button styles */
			.control-btn {
				position: absolute;
				bottom: 40px;
				transform: translateX(-50%);
				padding: 12px 24px;
				border-radius: 30px;
				border: 2px solid var(--color-border);
				background: var(--color-panel-bg);
				color: var(--color-text-muted);
				font-size: 14px;
				font-weight: 600;
				cursor: pointer;
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
				transition: all 0.2s;
				z-index: 20;
			}
			.control-btn:hover {
				background: var(--color-panel-hover);
				border-color: var(--color-border-light);
			}
			.control-btn.disabled {
				opacity: 0.3;
				pointer-events: none;
			}
			#status.waiting {
				background: rgba(100, 100, 120, 0.9);
			}
			#values {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
			}
			#latency {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
			}
			#hud-clock {
				position: absolute;
				top: 15px;
				left: 15px;
				font-size: 18px;
				color: rgba(0, 255, 0, 0.9);
				font-family: monospace;
				font-weight: bold;
				text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
				z-index: 20;
				pointer-events: none;
			}
			#turbo-btn {
				left: calc(50% + 80px);
			}
			#turbo-btn.active {
				background: rgba(255, 140, 0, 0.9);
				border-color: var(--color-turbo-border);
				color: #000;
			}
			#traction-btn {
				left: calc(50% - 80px);
			}
			#traction-btn.active {
				background: rgba(64, 145, 108, 0.9);
				border-color: rgba(82, 183, 136, 0.8);
				color: #fff;
			}
			@keyframes turbo-pulse {
				0% {
					opacity: 0.8;
				}
				100% {
					opacity: 1;
				}
			}

			/* Video stats overlay */
			#video-stats {
				position: absolute;
				bottom: 10px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.6);
				padding: 6px 12px;
				border-radius: 4px;
				font-size: 11px;
				font-family: monospace;
				color: rgba(255, 255, 255, 0.7);
				pointer-events: none;
				z-index: 10;
			}

			/* Control zones - positioned at bottom sides */
			.control-zone {
				position: absolute;
				bottom: 20px;
				width: 140px;
				height: 200px;
				background: rgba(30, 30, 50, 0.5);
				border-radius: 70px;
				border: 2px solid rgba(100, 100, 140, 0.3);
				display: flex;
				align-items: center;
				justify-content: center;
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
			}
			#throttle-zone {
				left: 20px;
			}
			#steering-zone {
				right: 20px;
				width: 220px;
				border-radius: 100px;
			}
			.control-zone .label {
				position: absolute;
				top: 12px;
				font-size: 10px;
				color: rgba(255, 255, 255, 0.3);
				text-transform: uppercase;
				letter-spacing: 2px;
			}

			/* Slider tracks */
			.slider-track {
				position: absolute;
				background: rgba(60, 60, 90, 0.5);
				border-radius: 8px;
			}
			#throttle-zone .slider-track {
				width: 8px;
				height: 120px;
			}
			#steering-zone .slider-track {
				height: 8px;
				width: 160px;
			}

			/* Thumbs */
			.slider-thumb {
				position: absolute;
				background: radial-gradient(circle at 30% 30%, rgba(150, 150, 200, 0.9), rgba(100, 100, 160, 0.9));
				border-radius: 50%;
				box-shadow:
					0 4px 20px rgba(0, 0, 0, 0.5),
					inset 0 1px 0 rgba(255, 255, 255, 0.2);
			}
			#throttle-thumb {
				width: 60px;
				height: 60px;
			}
			#steering-thumb {
				width: 60px;
				height: 60px;
			}

			/* Touch indicator when active */
			.control-zone.active {
				border-color: rgba(150, 150, 200, 0.5);
				background: rgba(40, 40, 70, 0.6);
			}

			#instructions {
				position: absolute;
				bottom: 240px;
				left: 0;
				right: 0;
				text-align: center;
				font-size: 11px;
				color: rgba(255, 255, 255, 0.2);
				pointer-events: none;
			}

			/* Shared fullscreen overlay styles */
			.fullscreen-overlay {
				position: absolute;
				inset: 0;
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 50;
			}
			.fullscreen-overlay.active {
				display: flex;
			}

			/* Countdown overlay */
			#countdown-overlay {
				background: rgba(0, 0, 0, 0.7);
			}
			#countdown-number {
				font-size: 200px;
				font-weight: 700;
				color: #fff;
				text-shadow: 0 0 60px rgba(255, 255, 255, 0.5);
				animation: countdown-pulse 1s ease-out;
			}
			#countdown-number.go {
				color: #40916c;
				font-size: 120px;
			}
			@keyframes countdown-pulse {
				0% {
					transform: scale(1.5);
					opacity: 0;
				}
				50% {
					opacity: 1;
				}
				100% {
					transform: scale(1);
					opacity: 1;
				}
			}

			/* Race timer in HUD */
			#race-timer {
				padding: 6px 14px;
				border-radius: 20px;
				font-size: 14px;
				font-weight: 700;
				font-family: monospace;
				background: rgba(0, 0, 0, 0.5);
				color: var(--color-success);
				display: none;
			}
			#race-timer.active {
				display: block;
			}

			/* Track map overlay */
			#track-map {
				position: absolute;
				top: 60px;
				right: 15px;
				max-width: 220px;
				background: rgba(0, 0, 0, 0.6);
				border-radius: 10px;
				overflow: hidden;
				pointer-events: none;
				display: none;
				z-index: 10;
			}
			#track-map.active {
				/* tmp disabled */
				/* display: block; */
			}
			#track-map img {
				display: block;
				width: 100%;
				height: auto;
				opacity: 0.8;
			}
			#track-map .car-dot {
				position: absolute;
				width: 18px;
				height: 18px;
				transform: translate(-50%, -50%);
				z-index: 1;
				filter: drop-shadow(0 0 4px rgba(255, 68, 68, 0.9));
			}
			#track-map .car-dot::before {
				content: '';
				position: absolute;
				inset: 0;
				background: #ff4444;
				clip-path: polygon(50% 0%, 100% 100%, 50% 70%, 0% 100%);
			}
			#track-map .no-fix {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 10px;
				color: rgba(255, 255, 255, 0.5);
				text-transform: uppercase;
				letter-spacing: 1px;
			}
			#track-map .speed-display {
				position: absolute;
				bottom: 18px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 14px;
				font-weight: 700;
				font-family: monospace;
				color: #fff;
				text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
			}
			#track-map .distance-display {
				position: absolute;
				bottom: 5px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 11px;
				font-family: monospace;
				color: rgba(255, 255, 255, 0.7);
				text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
			}

			/* Video game style compass strip */
			#compass-hud {
				position: absolute;
				top: 50px;
				left: 50%;
				transform: translateX(-50%);
				width: 280px;
				height: 28px;
				background: rgba(0, 0, 0, 0.5);
				border-radius: 4px;
				overflow: hidden;
				pointer-events: none;
				z-index: 10;
				display: none;
			}
			#compass-hud.active {
				display: block;
			}
			#compass-strip {
				position: absolute;
				top: 0;
				height: 100%;
				display: flex;
				align-items: center;
				white-space: nowrap;
				font-family: monospace;
				font-size: 11px;
				font-weight: 600;
				color: rgba(255, 255, 255, 0.5);
				text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
				will-change: transform;
			}
			#compass-strip .cardinal {
				color: #fff;
				font-size: 13px;
				font-weight: 700;
				padding: 0 1px;
			}
			#compass-strip .cardinal.north {
				color: #ff4444;
			}
			#compass-strip .tick {
				display: inline-block;
				width: 1px;
				height: 8px;
				background: rgba(255, 255, 255, 0.25);
				margin: 0 11px;
			}
			#compass-strip .deg {
				padding: 0 2px;
				min-width: 24px;
				text-align: center;
			}
			#compass-center-mark {
				position: absolute;
				top: 0;
				left: 50%;
				transform: translateX(-50%);
				width: 2px;
				height: 100%;
				background: #ff4444;
				box-shadow: 0 0 6px rgba(255, 68, 68, 0.8);
			}
			#compass-heading {
				position: absolute;
				top: 100%;
				left: 50%;
				transform: translateX(-50%);
				margin-top: 2px;
				font-size: 11px;
				font-family: monospace;
				font-weight: 600;
				color: rgba(255, 255, 255, 0.7);
				text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
			}

			/* Race stopped overlay */
			#stopped-overlay {
				background: rgba(0, 0, 0, 0.8);
			}
			#stopped-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 20px;
			}
			#stopped-text {
				font-size: 60px;
				font-weight: 700;
				color: var(--color-error);
				text-shadow: 0 0 40px rgba(230, 57, 70, 0.5);
				animation: stopped-flash 0.5s ease-out;
			}
			#stopped-time {
				font-size: 72px;
				font-weight: 700;
				font-family: monospace;
				color: var(--color-success);
				text-shadow: 0 0 30px rgba(64, 145, 108, 0.5);
				animation: stopped-flash 0.5s ease-out 0.2s both;
			}
			@keyframes stopped-flash {
				0% {
					transform: scale(1.3);
					opacity: 0;
				}
				100% {
					transform: scale(1);
					opacity: 1;
				}
			}

			/* Waiting for race overlay */
			#waiting-overlay {
				background: rgba(0, 0, 0, 0.6);
				z-index: 45;
				pointer-events: none;
			}
			#waiting-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 15px;
			}
			#waiting-text {
				font-size: 28px;
				font-weight: 600;
				color: #888;
				text-transform: uppercase;
				letter-spacing: 4px;
			}
			#waiting-spinner {
				width: 40px;
				height: 40px;
				border: 3px solid rgba(255, 255, 255, 0.1);
				border-top-color: rgba(255, 255, 255, 0.5);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			#ready-btn {
				padding: 20px 60px;
				font-size: 24px;
				font-weight: 700;
				border: none;
				border-radius: 16px;
				background: var(--color-success);
				color: white;
				cursor: pointer;
				text-transform: uppercase;
				letter-spacing: 3px;
				pointer-events: auto;
				margin-top: 20px;
				transition: all 0.2s ease;
				box-shadow: 0 4px 15px rgba(64, 145, 108, 0.4);
			}
			#ready-btn:hover:not(:disabled) {
				background: var(--color-success-light);
				transform: translateY(-2px);
				box-shadow: 0 6px 20px rgba(64, 145, 108, 0.5);
			}
			#ready-btn:active:not(:disabled) {
				transform: translateY(0);
			}
			#ready-btn:disabled {
				background: #555;
				color: #888;
				cursor: not-allowed;
				box-shadow: none;
			}

			/* Track Map Modal */
			#track-modal {
				position: fixed;
				inset: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				background: rgba(0, 0, 0, 0.85);
				z-index: 200;
			}
			#track-modal.hidden {
				display: none;
			}
			#track-modal-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 20px;
				max-width: 90vw;
				max-height: 90vh;
			}
			#track-modal-content img {
				max-width: 100%;
				max-height: 70vh;
				border-radius: 12px;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
			}
			#track-modal-content h2 {
				color: #eee;
				font-size: 24px;
				font-weight: 600;
			}
			#track-modal-actions {
				display: flex;
				gap: 15px;
				align-items: center;
			}
			#track-modal-close {
				padding: 12px 40px;
				font-size: 16px;
				border: none;
				border-radius: 10px;
				background: var(--color-success-dark);
				color: #eee;
				cursor: pointer;
				font-weight: 600;
			}
			#track-modal-close:hover {
				background: var(--color-success);
			}
			#track-modal-link {
				color: var(--color-accent);
				text-decoration: none;
				font-size: 14px;
			}
			#track-modal-link:hover {
				color: var(--color-accent-light);
				text-decoration: underline;
			}
		</style>
	</head>
	<body>
		<!-- Login Screen -->
		<div id="login-screen">
			<img src="logo.png" alt="Tether Rally" style="max-width: 340px; height: auto" />
			<input type="text" id="token-input" placeholder="Enter access token" autocomplete="off" />
			<div id="login-error"></div>
			<div id="device-status">Checking device...</div>
			<button id="connect-btn">Connect</button>
			<a href="/leaderboard.html" style="margin-top: 20px; color: #5a5a8a; text-decoration: none; font-size: 14px">üèÜ Leaderboard</a>

			<div class="info-section">
				<h2>üéÆ How It Works</h2>
				<p>
					Drive a <strong>real RC car</strong> remotely from your browser! You'll control an actual 1/10 scale vehicle via live video feed.
				</p>

				<h2>üì± Controls</h2>
				<ul>
					<li><strong>Mobile:</strong> Right stick steering, left trigger throttle</li>
					<li><strong>Desktop:</strong> Arrow keys or WASD</li>
				</ul>

				<h2>üèÅ What to Expect</h2>
				<ul>
					<li>Enter your access token to connect</li>
					<li>Wait for video feed to load</li>
					<li>Press <strong class="highlight">Ready</strong> when you're set</li>
					<li>Admin starts the race with countdown</li>
					<li>Complete the track as fast as you can!</li>
				</ul>
			</div>
		</div>

		<!-- Control Screen - Racing Game Style -->
		<div id="control-screen">
			<!-- Video Background -->
			<div id="video-container">
				<video id="fpv-video" autoplay playsinline muted></video>
				<div id="video-placeholder">
					<div class="spinner"></div>
					<span>Connecting video...</span>
				</div>
			</div>

			<!-- HUD Overlay -->
			<div id="hud">
				<div id="status" class="disconnected">Disconnected</div>
				<div id="race-timer">00:00.000</div>
				<div id="values">T: 0.000 | S: 0.000</div>
				<div id="latency">--ms</div>
			</div>

			<!-- Compass HUD (video game style horizontal strip) -->
			<div id="compass-hud">
				<div id="compass-strip"></div>
				<div id="compass-center-mark"></div>
				<div id="compass-heading">0¬∞</div>
			</div>

			<!-- Track Map Overlay -->
			<div id="track-map">
				<img id="track-image" src="" alt="Track" />
				<div class="car-dot" id="car-dot"></div>
				<div class="no-fix" id="no-gps-fix">No GPS</div>
				<div class="speed-display" id="speed-display">0 km/h</div>
				<div class="distance-display" id="distance-display"></div>
			</div>

			<!-- Countdown Overlay -->
			<div id="countdown-overlay" class="fullscreen-overlay">
				<div id="countdown-number">3</div>
			</div>

			<!-- Race Stopped Overlay -->
			<div id="stopped-overlay" class="fullscreen-overlay">
				<div id="stopped-content">
					<div id="stopped-text">FINISH</div>
					<div id="stopped-time">00:00.000</div>
				</div>
			</div>

			<!-- Waiting for Race Overlay -->
			<div id="waiting-overlay" class="fullscreen-overlay">
				<div id="waiting-content">
					<div id="waiting-spinner"></div>
					<div id="waiting-text">Waiting for race</div>
					<button id="ready-btn" disabled onclick="sendReady()">Ready</button>
				</div>
			</div>

			<!-- Video Stats -->
			<div id="video-stats"></div>

			<!-- Throttle (left side) -->
			<div id="throttle-zone" class="control-zone disabled">
				<div class="label">Throttle</div>
				<div class="slider-track"></div>
				<div id="throttle-thumb" class="slider-thumb"></div>
			</div>

			<!-- Steering (right side) -->
			<div id="steering-zone" class="control-zone disabled">
				<div class="label">Steering</div>
				<div class="slider-track"></div>
				<div id="steering-thumb" class="slider-thumb"></div>
			</div>

			<div id="instructions">WASD / Arrow keys | E = Turbo | Q = Traction</div>

			<!-- Control Buttons -->
			<button id="traction-btn" class="control-btn disabled" onclick="toggleTraction()">üõû TC (Q)</button>
			<button id="turbo-btn" class="control-btn disabled" onclick="toggleTurbo()">üöÄ TURBO (E)</button>
		</div>

		<!-- Optional: Load config.js for deployment-specific URLs -->
		<script src="config.js" onerror="console.log('No config.js found, using defaults')"></script>

		<script>
			// ===== CONFIGURATION =====
			// These URLs should be configured for your deployment
			// For development, set DEV=true and update local URLs
			// For production, update the production URLs to match your domain
			const DEV = false;

			// Cloudflare Workers (static assets + TURN credentials)
			// Production: Your worker URL (e.g., https://your-app.workers.dev)
			const WORKER_URL = DEV ? 'http://localhost:8787' : window.WORKER_URL || window.location.origin;

			// FPV Camera (MediaMTX WHEP via Cloudflare Tunnel)
			// Production: Your camera tunnel URL (e.g., https://cam.yourdomain.com/cam/whep)
			const CAMERA_WHEP_URL = DEV ? 'http://pi.local:8889/cam/whep' : window.CAMERA_WHEP_URL || '';

			// Control Relay (WebRTC DataChannel signaling via Cloudflare Tunnel)
			// Production: Your control tunnel URL (e.g., https://control.yourdomain.com)
			const CONTROL_URL = DEV ? 'http://localhost:8890' : window.CONTROL_URL || '';
			// =========================

			// ===== TIMING CONSTANTS =====
			const CONTROL_INTERVAL_MS = 20; // 50Hz control loop
			const PING_INTERVAL_MS = 500;
			const DEVICE_CHECK_INTERVAL_MS = 5000;
			const ICE_RECOVERY_TIMEOUT_MS = 5000;
			const ICE_GATHERING_TIMEOUT_MS = 2000;
			const VIDEO_RECONNECT_DELAY_MS = 3000;
			const VIDEO_CHECK_DELAY_MS = 1000;
			const TURN_CREDENTIAL_REFRESH_MS = 12 * 60 * 60 * 1000; // 12 hours
			const MAX_RECONNECT_DELAY_MS = 30000;
			const COUNTDOWN_STEP_MS = 1000;
			const COUNTDOWN_GO_MS = 3000;
			const COUNTDOWN_HIDE_MS = 3500;
			const FINISH_DISPLAY_MS = 4000;
			// ============================

			// ===== PROTOCOL CONSTANTS =====

			const CMD_PING = 0x00;
			const CMD_CTRL = 0x01;
			const CMD_PONG = 0x02;
			const CMD_RACE = 0x03;
			const CMD_STATUS = 0x04;
			const CMD_CONFIG = 0x05;
			const CMD_KICK = 0x06; // Pi -> Browser: you have been kicked
			const CMD_TELEM = 0x07; // Pi -> Browser: telemetry broadcast
			const CMD_TURBO = 0x08; // Browser -> Pi: turbo mode toggle
			const CMD_TRACTION = 0x09; // Browser -> Pi: traction control toggle

			// Race sub-commands
			const RACE_START_COUNTDOWN = 0x01;
			const RACE_STOP = 0x02;

			// Status sub-commands
			const STATUS_VIDEO = 0x01; // payload: 1 byte (0=disconnected, 1=connected)
			const STATUS_READY = 0x02; // payload: 1 byte (0=not ready, 1=ready)

			let playerReady = false;

			function sendVideoStatus(connected) {
				if (controlChannel && controlChannel.readyState === 'open') {
					const buf = new ArrayBuffer(5);
					const view = new DataView(buf);
					view.setUint16(0, 0, true); // seq=0 for status messages
					view.setUint8(2, CMD_STATUS);
					view.setUint8(3, STATUS_VIDEO);
					view.setUint8(4, connected ? 1 : 0);
					controlChannel.send(buf);
					console.log('Sent video status:', connected);
					// Enable ready button when video is connected
					if (connected && !playerReady) {
						readyBtn.disabled = false;
					}
				}
			}

			function sendReady() {
				if (controlChannel && controlChannel.readyState === 'open' && !playerReady) {
					const buf = new ArrayBuffer(5);
					const view = new DataView(buf);
					view.setUint16(0, 0, true);
					view.setUint8(2, CMD_STATUS);
					view.setUint8(3, STATUS_READY);
					view.setUint8(4, 1);
					controlChannel.send(buf);
					playerReady = true;
					readyBtn.textContent = '‚úì Ready';
					readyBtn.classList.add('ready');
					readyBtn.disabled = true;
					waitingText.textContent = 'Waiting for admin';
					console.log('Sent ready status');
				}
			}

			const TOKEN_STORAGE_KEY = 'tether-rally-token';
			let controlSeq = 0;

			let controlPc = null;
			let controlChannel = null;
			let pingInterval = null;
			let controlInterval = null;
			let currentToken = null;
			let thrSlider = 0;
			let thr = 0;
			let str = 0;
			let strTarget = 0; // Target steering for keyboard (for smooth interpolation)
			let latency = 0;
			let isConnected = false;
			let deviceOnline = false;
			let videoConnected = false;
			const keys = new Set();
			let turboMode = false; // Turbo mode state
			let tractionMode = false; // Traction control state
			const keyStep = 1.0;
			const strStep = 1.0;
			const strSmoothRate = 0.15; // How fast steering interpolates (0-1, lower = smoother)

			// Race state
			let raceStartTime = null;
			let raceTimerInterval = null;

			// GPS telemetry state
			let gpsLat = 0;
			let gpsLon = 0;
			let gpsSpeed = 0;
			let gpsHeading = 0;
			let gpsFix = false;

			// IMU telemetry state
			let imuHeading = 0; // Blended heading from IMU
			let imuCalibration = 0; // Packed calibration byte
			let yawRate = 0; // Yaw rate (deg/sec)
			let smoothedHeading = 0; // Client-side smoothed for rendering
			let compassBuilt = false; // Track if compass strip is built

			// Distance tracking (during race)
			let prevGpsLat = null;
			let prevGpsLon = null;
			let totalDistance = 0; // in meters (GPS-based, fallback)
			let wheelDistance = 0; // in meters (from wheel sensor, more accurate)
			let isRacing = false;

			// Track map configuration
			// Set these for each track: two opposite corners (SW and NE)
			let trackConfig = null;
			// Example:
			// trackConfig = {
			//   image: '/tracks/mytrack.png',
			//   sw: { lat: 1, lon: 1 },  // Southwest corner
			//   ne: { lat: 1, lon: 1 }   // Northeast corner
			// };

			// DOM elements
			const loginScreen = document.getElementById('login-screen');
			const controlScreen = document.getElementById('control-screen');
			const tokenInput = document.getElementById('token-input');
			const connectBtn = document.getElementById('connect-btn');
			const loginError = document.getElementById('login-error');
			const deviceStatusEl = document.getElementById('device-status');
			const fpvVideo = document.getElementById('fpv-video');
			const videoPlaceholder = document.getElementById('video-placeholder');
			const statusEl = document.getElementById('status');
			const valuesEl = document.getElementById('values');
			const latencyEl = document.getElementById('latency');
			const throttleZone = document.getElementById('throttle-zone');
			const steeringZone = document.getElementById('steering-zone');
			const throttleThumb = document.getElementById('throttle-thumb');
			const steeringThumb = document.getElementById('steering-thumb');
			const countdownOverlay = document.getElementById('countdown-overlay');
			const countdownNumber = document.getElementById('countdown-number');
			const raceTimerEl = document.getElementById('race-timer');
			const stoppedOverlay = document.getElementById('stopped-overlay');
			const waitingOverlay = document.getElementById('waiting-overlay');
			const readyBtn = document.getElementById('ready-btn');
			const waitingText = document.getElementById('waiting-text');
			const turboBtn = document.getElementById('turbo-btn');
			const tractionBtn = document.getElementById('traction-btn');

			let throttleTouchId = null;
			let steeringTouchId = null;
			let throttleTouchOrigin = null;
			let steeringTouchOrigin = null;
			let mouseThrOrigin = null;
			let mouseStrOrigin = null;

			// ===== HELPER FUNCTIONS =====
			// Format milliseconds to MM:SS.mmm
			function formatTime(ms) {
				const mins = Math.floor(ms / 60000);
				const secs = Math.floor((ms % 60000) / 1000);
				const millis = ms % 1000;
				return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
			}

			// Create a binary packet with auto-incrementing sequence
			function createPacket(cmd, payloadSize = 0) {
				controlSeq = (controlSeq + 1) & 0xffff;
				const buf = new ArrayBuffer(3 + payloadSize);
				const view = new DataView(buf);
				view.setUint16(0, controlSeq, true);
				view.setUint8(2, cmd);
				return { buf, view };
			}

			// Reset throttle state
			function resetThrottle() {
				throttleTouchId = null;
				throttleTouchOrigin = null;
				mouseThrOrigin = null;
				throttleZone.classList.remove('active');
				thrSlider = 0;
				thr = 0;
				sendControl();
			}

			// Reset steering state
			function resetSteering() {
				steeringTouchId = null;
				steeringTouchOrigin = null;
				mouseStrOrigin = null;
				steeringZone.classList.remove('active');
				str = 0;
				sendControl();
			}
			// ============================

			// Check device status from control relay health endpoint
			async function checkDeviceStatus() {
				try {
					const res = await fetch(`${CONTROL_URL}/control/health`);
					const data = await res.json();
					deviceOnline = data.esp32_ip !== null;
					deviceStatusEl.textContent = deviceOnline ? 'üü¢ Device online' : 'üî¥ Device offline';
					deviceStatusEl.className = deviceOnline ? 'online' : '';
				} catch (e) {
					deviceStatusEl.textContent = '‚ö†Ô∏è Cannot reach relay';
					deviceOnline = false;
				}
			}

			// Check status on load and periodically
			checkDeviceStatus();
			setInterval(checkDeviceStatus, DEVICE_CHECK_INTERVAL_MS);

			// Load track config from window.TRACK_CONFIG if set in config.js
			if (window.TRACK_CONFIG) {
				setTrackConfig(window.TRACK_CONFIG);
			}

			function setStatus(state, text) {
				statusEl.className = state;
				statusEl.textContent = text;
			}

			function updateDisplay() {
				valuesEl.textContent = `T: ${thr.toFixed(3)} | S: ${str.toFixed(3)}`;
			}

			function updateThumbs() {
				const thrZoneRect = throttleZone.getBoundingClientRect();
				const thrRange = (thrZoneRect.height - 80) / 2;
				throttleThumb.style.left = '50%';
				throttleThumb.style.top = `calc(50% - ${thrSlider * thrRange}px)`;
				throttleThumb.style.transform = 'translate(-50%, -50%)';

				const strZoneRect = steeringZone.getBoundingClientRect();
				const strRange = (strZoneRect.width - 80) / 2;
				steeringThumb.style.top = '50%';
				steeringThumb.style.left = `calc(50% + ${str * strRange}px)`;
				steeringThumb.style.transform = 'translate(-50%, -50%)';
			}

			function sendPing() {
				if (controlChannel && controlChannel.readyState === 'open') {
					// Packet: seq(2) + cmd(1) + timestamp(4) = 7 bytes
					const buf = new ArrayBuffer(7);
					const view = new DataView(buf);
					controlSeq = (controlSeq + 1) & 0xffff;
					view.setUint16(0, controlSeq, true);
					view.setUint8(2, CMD_PING);
					view.setUint32(3, performance.now() & 0xffffffff, true);
					controlChannel.send(buf);
				}
			}

			function sendControl() {
				// Smooth keyboard steering interpolation (only when using keyboard)
				if (keys.size > 0 || str !== strTarget) {
					str += (strTarget - str) * strSmoothRate;
					// Snap to target when very close
					if (Math.abs(str - strTarget) < 0.01) str = strTarget;
				}

				if (controlChannel && controlChannel.readyState === 'open') {
					// Packet: seq(2) + cmd(1) + thr(2) + str(2) = 7 bytes
					const buf = new ArrayBuffer(7);
					const view = new DataView(buf);
					controlSeq = (controlSeq + 1) & 0xffff;
					view.setUint16(0, controlSeq, true);
					view.setUint8(2, CMD_CTRL);
					view.setInt16(3, Math.round(thr * 32767), true);
					view.setInt16(5, Math.round(str * 32767), true);
					controlChannel.send(buf);
				}
				updateDisplay();
				updateThumbs();
			}

			function showLoginScreen() {
				loginScreen.classList.remove('hidden');
				controlScreen.classList.remove('active');
				document.body.classList.remove('race-mode');
				connectBtn.disabled = false;
				connectBtn.textContent = 'Connect';
				stopFpvStream();
				stopControlChannel();
			}

			function showControlScreen() {
				loginScreen.classList.add('hidden');
				controlScreen.classList.add('active');
				document.body.classList.add('race-mode');
				startFpvStream();
			}

			// ===== WebRTC FPV Stream =====
			let fpvPeerConnection = null;
			let cachedIceServers = null;

			async function getIceServers() {
				// Use cached credentials if available and not expired
				if (cachedIceServers) {
					return cachedIceServers;
				}

				try {
					const response = await fetch(`${WORKER_URL}/turn-credentials`);
					if (response.ok) {
						const data = await response.json();
						cachedIceServers = data.iceServers;
						// Refresh credentials after 12 hours (they last 24h)
						setTimeout(() => {
							cachedIceServers = null;
						}, TURN_CREDENTIAL_REFRESH_MS);
						console.log('Got Cloudflare TURN credentials');
						return cachedIceServers;
					}
				} catch (err) {
					console.warn('Failed to get TURN credentials, falling back to STUN only:', err);
				}

				// Fallback to STUN only (won't work through NAT)
				return [{ urls: 'stun:stun.l.google.com:19302' }];
			}

			async function startFpvStream() {
				if (fpvPeerConnection) {
					stopFpvStream();
				}

				try {
					const iceServers = await getIceServers();
					fpvPeerConnection = new RTCPeerConnection({ iceServers });

					fpvPeerConnection.ontrack = (event) => {
						fpvVideo.srcObject = event.streams[0];
						videoPlaceholder.style.display = 'none';
						videoConnected = true;
						throttleZone.classList.remove('disabled');
						steeringZone.classList.remove('disabled');
						sendVideoStatus(true);
						// Enable ready button when video connects (if not already ready)
						if (!playerReady) {
							readyBtn.disabled = false;
						}
					};

					fpvPeerConnection.oniceconnectionstatechange = () => {
						const state = fpvPeerConnection.iceConnectionState;
						console.log('FPV ICE state:', state);
						if (state === 'disconnected' || state === 'failed') {
							// 'disconnected' can be temporary - check if video is actually playing
							// Only show overlay if video has truly stopped (no frames for 2s)
							const checkVideoPlaying = () => {
								// If video is playing and has recent frames, don't show disconnected overlay
								if (fpvVideo.srcObject && !fpvVideo.paused && fpvVideo.readyState >= 2) {
									console.log('FPV ICE disconnected but video still playing, ignoring');
									return;
								}
								// Video actually stopped
								videoPlaceholder.innerHTML = '<div class="spinner"></div><span>FPV Disconnected - Reconnecting...</span>';
								videoPlaceholder.style.display = 'flex';
								videoConnected = false;
								sendVideoStatus(false);
							};

							// Wait a moment before declaring disconnected (ICE can recover quickly)
							setTimeout(checkVideoPlaying, VIDEO_CHECK_DELAY_MS);

							// Try to reconnect video after a longer delay if still disconnected
							setTimeout(() => {
								if (
									!fpvPeerConnection ||
									fpvPeerConnection.iceConnectionState === 'disconnected' ||
									fpvPeerConnection.iceConnectionState === 'failed'
								) {
									console.log('Reconnecting FPV stream...');
									startFpvStream();
								}
							}, VIDEO_RECONNECT_DELAY_MS);
						} else if (state === 'connected' || state === 'completed') {
							// ICE reconnected - hide overlay if video is playing
							if (fpvVideo.srcObject && !fpvVideo.paused) {
								videoPlaceholder.style.display = 'none';
								videoConnected = true;
								sendVideoStatus(true);
							}
						}
					};

					// Add transceivers for receiving video/audio
					fpvPeerConnection.addTransceiver('video', { direction: 'recvonly' });
					fpvPeerConnection.addTransceiver('audio', { direction: 'recvonly' });

					// Create offer
					const offer = await fpvPeerConnection.createOffer();
					await fpvPeerConnection.setLocalDescription(offer);

					// Wait for ICE gathering with timeout (TURN gathering can be slow)
					await new Promise((resolve) => {
						if (fpvPeerConnection.iceGatheringState === 'complete') {
							resolve();
							return;
						}

						const timeout = setTimeout(() => {
							console.log('ICE gathering timeout, proceeding with available candidates');
							resolve();
						}, ICE_GATHERING_TIMEOUT_MS); // 2 second max wait

						fpvPeerConnection.onicegatheringstatechange = () => {
							if (fpvPeerConnection.iceGatheringState === 'complete') {
								clearTimeout(timeout);
								resolve();
							}
						};
					});

					// Send offer to MediaMTX WHEP endpoint
					const response = await fetch(CAMERA_WHEP_URL, {
						method: 'POST',
						headers: { 'Content-Type': 'application/sdp' },
						body: fpvPeerConnection.localDescription.sdp,
					});

					if (!response.ok) {
						throw new Error(`WHEP error: ${response.status}`);
					}

					// Set remote description from answer
					const answer = await response.text();
					await fpvPeerConnection.setRemoteDescription({
						type: 'answer',
						sdp: answer,
					});

					console.log('Video stream connected');
					startVideoStats();
				} catch (err) {
					console.error('Video stream error:', err);
					videoPlaceholder.innerHTML = '<span>FPV Unavailable</span>';
					videoPlaceholder.style.display = 'flex';
				}
			}

			// Video stats tracking
			let videoStatsInterval = null;
			let lastBytesReceived = 0;
			let lastStatsTime = 0;
			const videoStatsEl = document.getElementById('video-stats');

			async function updateVideoStats() {
				if (!fpvPeerConnection) return;

				try {
					const stats = await fpvPeerConnection.getStats();
					let fps = 0;
					let bitrate = 0;
					let videoLatency = 0;
					let resolution = '';

					stats.forEach((report) => {
						if (report.type === 'inbound-rtp' && report.kind === 'video') {
							// FPS
							if (report.framesPerSecond) {
								fps = Math.round(report.framesPerSecond);
							}

							// Resolution
							if (report.frameWidth && report.frameHeight) {
								resolution = `${report.frameWidth}x${report.frameHeight}`;
							}

							// Bitrate (calculated from bytes received)
							const now = Date.now();
							if (lastStatsTime > 0 && report.bytesReceived) {
								const timeDelta = (now - lastStatsTime) / 1000;
								const bytesDelta = report.bytesReceived - lastBytesReceived;
								bitrate = Math.round((bytesDelta * 8) / timeDelta / 1000); // kbps
							}
							lastBytesReceived = report.bytesReceived || 0;
							lastStatsTime = now;

							// Jitter as proxy for latency variability
							if (report.jitter) {
								videoLatency = Math.round(report.jitter * 1000);
							}
						}

						// RTT from candidate pair
						if (report.type === 'candidate-pair' && report.state === 'succeeded') {
							if (report.currentRoundTripTime) {
								videoLatency = Math.round(report.currentRoundTripTime * 1000);
							}
						}
					});

					// Update display
					const parts = [];
					if (resolution) parts.push(resolution);
					if (fps > 0) parts.push(`${fps}fps`);
					if (bitrate > 0) parts.push(`${bitrate}kbps`);
					if (videoLatency > 0) parts.push(`${videoLatency}ms`);

					videoStatsEl.textContent = parts.length > 0 ? parts.join(' ‚Ä¢ ') : '';
				} catch (err) {
					// Ignore stats errors
				}
			}

			function startVideoStats() {
				stopVideoStats();
				lastBytesReceived = 0;
				lastStatsTime = 0;
				videoStatsInterval = setInterval(updateVideoStats, 1000);
			}

			function stopVideoStats() {
				if (videoStatsInterval) {
					clearInterval(videoStatsInterval);
					videoStatsInterval = null;
				}
				videoStatsEl.textContent = '';
			}

			function stopFpvStream() {
				stopVideoStats();
				if (fpvPeerConnection) {
					fpvPeerConnection.close();
					fpvPeerConnection = null;
				}
				fpvVideo.srcObject = null;
				videoConnected = false;
				videoPlaceholder.innerHTML = '<div class="spinner"></div><span>Connecting video...</span>';
				videoPlaceholder.style.display = 'flex';
				throttleZone.classList.add('disabled');
				steeringZone.classList.add('disabled');
			}
			// =============================

			// ===== Race Countdown & Timer =====
			function showCountdown() {
				countdownOverlay.classList.add('active');
				countdownNumber.textContent = '3';
				countdownNumber.className = '';

				setTimeout(() => {
					countdownNumber.textContent = '2';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
				}, COUNTDOWN_STEP_MS);

				setTimeout(() => {
					countdownNumber.textContent = '1';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
				}, COUNTDOWN_STEP_MS * 2);

				setTimeout(() => {
					countdownNumber.textContent = 'GO!';
					countdownNumber.className = 'go';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
				}, COUNTDOWN_GO_MS);

				setTimeout(() => {
					countdownOverlay.classList.remove('active');
					startRaceTimer();
				}, COUNTDOWN_HIDE_MS);
			}

			function startRaceTimer() {
				raceStartTime = Date.now();
				raceTimerEl.classList.add('active');

				if (raceTimerInterval) clearInterval(raceTimerInterval);
				raceTimerInterval = setInterval(updateRaceTimer, 50);
			}

			function updateRaceTimer() {
				if (!raceStartTime) return;
				const elapsed = Date.now() - raceStartTime;
				raceTimerEl.textContent = formatTime(elapsed);
			}

			function stopRaceTimer() {
				if (raceTimerInterval) {
					clearInterval(raceTimerInterval);
					raceTimerInterval = null;
				}
				raceStartTime = null;
				raceTimerEl.classList.remove('active');
			}

			function handleRaceCommand(subCmd) {
				console.log('Race command received:', subCmd);
				const RACE_RESUME = 0x03; // Reconnected during active race
				switch (subCmd) {
					case RACE_START_COUNTDOWN:
						stoppedOverlay.classList.remove('active'); // Hide stopped overlay if visible
						waitingOverlay.classList.remove('active'); // Hide waiting overlay
						// Reset distance tracking
						totalDistance = 0;
						wheelDistance = 0;
						prevGpsLat = null;
						prevGpsLon = null;
						isRacing = true;
						showCountdown();
						break;
					case RACE_RESUME:
						// Reconnected during active race - enable controls immediately
						console.log('Race resume - enabling controls');
						stoppedOverlay.classList.remove('active');
						waitingOverlay.classList.remove('active');
						countdownOverlay.classList.remove('active');
						isRacing = true;
						// Start timer from 0 (we don't know the actual elapsed time)
						raceStartTime = Date.now();
						raceTimerEl.classList.add('active');
						if (!raceTimerInterval) {
							raceTimerInterval = setInterval(updateRaceTimer, 50);
						}
						break;
					case RACE_STOP:
						isRacing = false;
						// Capture final time before stopping
						let finalTime = '00:00.000';
						if (raceStartTime) {
							const elapsed = Date.now() - raceStartTime;
							finalTime = formatTime(elapsed);
						}

						stopRaceTimer();
						countdownOverlay.classList.remove('active'); // Hide countdown if in progress

						// Show stopped overlay with final time
						document.getElementById('stopped-time').textContent = finalTime;
						stoppedOverlay.classList.add('active');
						setTimeout(() => {
							stoppedOverlay.classList.remove('active');
							waitingOverlay.classList.add('active'); // Show waiting overlay after finish fades
						}, FINISH_DISPLAY_MS); // Show longer so they can see the time
						break;
				}
			}

			function handleConfigCommand(data) {
				// Format: seq(2) + cmd(1) + reserved(1) + turbo(1) + traction(1)
				if (data.byteLength >= 6) {
					const view = new DataView(data);
					turboMode = view.getUint8(4) !== 0;
					tractionMode = view.getUint8(5) !== 0;
					updateTurboIndicator();
					updateTractionIndicator();
					console.log('Config received: turbo =', turboMode, ', traction =', tractionMode);
				}
			}

			// ===== TOGGLE FEATURE FACTORY =====
			// Creates reusable toggle functions for turbo/traction-like features
			function createToggleFeature(name, cmd, btnEl) {
				return {
					updateIndicator(mode) {
						btnEl.classList.toggle('active', mode);
					},
					send(enabled) {
						if (controlChannel && controlChannel.readyState === 'open') {
							const { buf, view } = createPacket(cmd, 1);
							view.setUint8(3, enabled ? 1 : 0);
							controlChannel.send(buf);
							console.log(`Sent ${name}:`, enabled, 'seq:', controlSeq);
						}
					},
					updateButton() {
						btnEl.classList.toggle('disabled', !isConnected);
					},
				};
			}

			// Create turbo and traction toggle features
			const turboFeature = createToggleFeature('turbo', CMD_TURBO, turboBtn);
			const tractionFeature = createToggleFeature('traction', CMD_TRACTION, tractionBtn);

			// Convenience functions for backward compatibility
			function updateTurboIndicator() {
				turboFeature.updateIndicator(turboMode);
			}
			function updateTractionIndicator() {
				tractionFeature.updateIndicator(tractionMode);
			}
			function updateTurboButton() {
				turboFeature.updateButton();
			}
			function updateTractionButton() {
				tractionFeature.updateButton();
			}

			function toggleTurbo() {
				if (!isConnected) return;
				turboMode = !turboMode;
				turboFeature.send(turboMode);
				updateTurboIndicator();
			}

			function toggleTraction() {
				if (!isConnected) return;
				tractionMode = !tractionMode;
				tractionFeature.send(tractionMode);
				updateTractionIndicator();
			}

			function handleKicked() {
				console.log('Kicked by admin');
				// Stop everything
				stopFpvStream();
				stopControlChannel();
				// Reset ready state
				playerReady = false;
				readyBtn.textContent = 'Ready';
				readyBtn.classList.remove('ready');
				readyBtn.disabled = true;
				waitingText.textContent = 'Waiting for race';
				// Clear token so they can't auto-reconnect
				currentToken = null;
				// Show kicked message
				loginError.textContent = 'You have been kicked by the admin';
				loginError.style.display = 'block';
				// Go back to login screen
				showLoginScreen();
			}

			function handleTelemetry(view) {
				// Parse telemetry packet
				// Old format (24 bytes): seq(2) + cmd(1) + race_time(4) + throttle(2) + steering(2) + lat(4) + lon(4) + speed(2) + heading(2) + fix(1)
				// IMU format (29 bytes): + imu_heading(2) + calibration(1) + yaw_rate(2)
				// Wheel format (33 bytes): + wheel_distance(4)
				const raceTimeMs = view.getUint32(3, true);
				// const telem_throttle = view.getInt16(7, true);  // Not used currently
				// const telem_steering = view.getInt16(9, true);  // Not used currently
				gpsLat = view.getInt32(11, true) / 1e7; // Scaled lat back to degrees
				gpsLon = view.getInt32(15, true) / 1e7; // Scaled lon back to degrees
				gpsSpeed = view.getUint16(19, true) / 100; // Scaled speed back to km/h (now fused speed)
				gpsHeading = view.getUint16(21, true) / 100; // Scaled heading back to degrees
				gpsFix = view.getUint8(23) === 1;

				// Parse IMU fields if present (29+ byte format)
				if (view.byteLength >= 29) {
					imuHeading = view.getUint16(24, true) / 100; // Blended heading in degrees
					imuCalibration = view.getUint8(26); // Packed calibration
					yawRate = view.getInt16(27, true) / 100; // Yaw rate in deg/sec

					// Smooth heading for rendering (handles wrap-around)
					smoothedHeading = smoothAngle(smoothedHeading, imuHeading, 0.25);
				}

				// Parse wheel distance if present (33-byte format)
				if (view.byteLength >= 33) {
					wheelDistance = view.getUint32(29, true) / 100; // cm to meters
				}

				// Update track map and compass
				updateTrackMap();
				updateCompassHUD();
			}

			// Smooth angle transition with wrap-around handling
			function smoothAngle(current, target, alpha) {
				const diff = Math.atan2(Math.sin(((target - current) * Math.PI) / 180), Math.cos(((target - current) * Math.PI) / 180));
				return (current + (alpha * diff * 180) / Math.PI + 360) % 360;
			}

			// Haversine formula to calculate distance between two GPS points (returns meters)
			function haversineDistance(lat1, lon1, lat2, lon2) {
				const R = 6371000; // Earth's radius in meters
				const dLat = ((lat2 - lat1) * Math.PI) / 180;
				const dLon = ((lon2 - lon1) * Math.PI) / 180;
				const a =
					Math.sin(dLat / 2) * Math.sin(dLat / 2) +
					Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				return R * c;
			}

			function updateTrackMap() {
				const trackMap = document.getElementById('track-map');
				const carDot = document.getElementById('car-dot');
				const noGpsFix = document.getElementById('no-gps-fix');
				const speedDisplay = document.getElementById('speed-display');
				const distanceDisplay = document.getElementById('distance-display');

				// Update speed display
				speedDisplay.textContent = `${Math.round(gpsSpeed)} km/h`;

				// Accumulate GPS distance as fallback (if wheel sensor not available)
				if (isRacing && gpsFix && prevGpsLat !== null && prevGpsLon !== null) {
					const dist = haversineDistance(prevGpsLat, prevGpsLon, gpsLat, gpsLon);
					// Filter out GPS jumps (> 10m between updates is suspicious at low speeds)
					if (dist < 10) {
						totalDistance += dist;
					}
				}
				if (gpsFix) {
					prevGpsLat = gpsLat;
					prevGpsLon = gpsLon;
				}

				// Update distance display - prefer wheel distance (more accurate), fallback to GPS
				const displayDistance = wheelDistance > 0 ? wheelDistance : totalDistance;
				if (displayDistance > 0) {
					distanceDisplay.textContent = `${(displayDistance / 1000).toFixed(2)} km`;
				} else {
					distanceDisplay.textContent = '';
				}

				// Show/hide GPS fix indicator
				if (!gpsFix) {
					noGpsFix.style.display = 'block';
					carDot.style.display = 'none';
					return;
				}

				noGpsFix.style.display = 'none';
				carDot.style.display = 'block';

				// If no track config, can't position the dot
				if (!trackConfig) {
					return;
				}

				// Check if coordinates are within track bounds
				const isOutOfBounds =
					gpsLat < trackConfig.sw.lat || gpsLat > trackConfig.ne.lat || gpsLon < trackConfig.sw.lon || gpsLon > trackConfig.ne.lon;

				if (isOutOfBounds) {
					carDot.style.display = 'none';
					return;
				}

				// Calculate position on map (0-100%)
				// Map GPS coordinates to pixel position within the track bounds
				const latRange = trackConfig.ne.lat - trackConfig.sw.lat;
				const lonRange = trackConfig.ne.lon - trackConfig.sw.lon;

				// Calculate percentage position (0-100)
				// X: longitude (left=0, right=100)
				// Y: latitude (bottom=0, top=100, but CSS top is inverted)
				const xPercent = ((gpsLon - trackConfig.sw.lon) / lonRange) * 100;
				const yPercent = 100 - ((gpsLat - trackConfig.sw.lat) / latRange) * 100; // Invert for CSS

				carDot.style.left = `${xPercent}%`;
				carDot.style.top = `${yPercent}%`;

				// Rotate arrow to show heading (0¬∞ = North = up)
				carDot.style.transform = `translate(-50%, -50%) rotate(${smoothedHeading}deg)`;
			}

			// Build compass strip HTML (called once)
			function buildCompassStrip(container) {
				// Build 720¬∞ of compass (duplicate for seamless wrapping)
				// Cardinals every 45¬∞, degrees every 15¬∞
				const directions = {
					0: 'N',
					45: 'NE',
					90: 'E',
					135: 'SE',
					180: 'S',
					225: 'SW',
					270: 'W',
					315: 'NW',
				};

				let html = '';
				for (let deg = 0; deg < 720; deg += 15) {
					const actualDeg = deg % 360;
					const dir = directions[actualDeg];

					if (dir) {
						// Cardinal or intercardinal
						const isNorth = actualDeg === 0;
						html += `<span class="cardinal${isNorth ? ' north' : ''}">${dir}</span>`;
					} else {
						// Degree number
						html += `<span class="deg">${actualDeg}</span>`;
					}
				}
				container.innerHTML = html;
			}

			// Update compass HUD display
			function updateCompassHUD() {
				const compassHUD = document.getElementById('compass-hud');
				const compassStrip = document.getElementById('compass-strip');
				const headingDisplay = document.getElementById('compass-heading');

				// Show compass when we have IMU data
				if (imuCalibration === 0 && !gpsFix) {
					compassHUD.classList.remove('active');
					return;
				}

				compassHUD.classList.add('active');

				// Build compass strip if not already done
				if (!compassBuilt) {
					buildCompassStrip(compassStrip);
					compassBuilt = true;
				}

				// Each 15¬∞ segment is about 25px wide (adjust based on CSS spacing)
				// Strip total = 720¬∞ = 48 segments
				const pixelsPerDegree = 25 / 15; // ~1.67 px per degree
				const offset = smoothedHeading * pixelsPerDegree;

				// Center the strip (140px = half of 280px container width)
				compassStrip.style.transform = `translateX(${140 - offset}px)`;

				// Show numeric heading
				headingDisplay.textContent = `${Math.round(smoothedHeading)}¬∞`;
			}

			function setTrackConfig(config) {
				// Set track configuration and show the map
				// config = { image: '/tracks/mytrack.png', sw: {lat, lon}, ne: {lat, lon} }
				trackConfig = config;
				const trackMap = document.getElementById('track-map');
				const trackImage = document.getElementById('track-image');

				if (config) {
					trackImage.src = config.image;
					trackMap.classList.add('active');
				} else {
					trackMap.classList.remove('active');
				}
			}

			// ==================================

			// ===== WebRTC DataChannel for Controls =====
			let iceRecoveryTimeout = null; // Track the reconnect timeout

			async function startControlChannel() {
				const iceServers = await getIceServers();

				controlPc = new RTCPeerConnection({ iceServers });

				// Handle ICE connection state changes (including disconnection)
				controlPc.oniceconnectionstatechange = () => {
					console.log('Control ICE state:', controlPc.iceConnectionState);
					const state = controlPc.iceConnectionState;

					if (state === 'connected' || state === 'completed') {
						// Cancel any pending reconnect timeout
						if (iceRecoveryTimeout) {
							clearTimeout(iceRecoveryTimeout);
							iceRecoveryTimeout = null;
							console.log('ICE recovered, cancelled reconnect');
						}

						// Restore UI if DataChannel is still open
						if (controlChannel && controlChannel.readyState === 'open') {
							isConnected = true;
							setStatus('connected', 'Connected');
							throttleZone.classList.remove('disabled');
							steeringZone.classList.remove('disabled');
						}

						// Log the selected candidate pair
						controlPc.getStats().then((stats) => {
							stats.forEach((report) => {
								if (report.type === 'candidate-pair' && report.state === 'succeeded') {
									const localId = report.localCandidateId;
									const remoteId = report.remoteCandidateId;
									stats.forEach((r) => {
										if (r.id === localId) console.log('Control local candidate:', r.candidateType, r.address);
										if (r.id === remoteId) console.log('Control remote candidate:', r.candidateType, r.address);
									});
								}
							});
						});
					} else if (state === 'disconnected') {
						// Connection lost - update UI immediately
						console.warn('Control connection lost');
						isConnected = false;
						setStatus('disconnected', 'Connection Lost');
						throttleZone.classList.add('disabled');
						steeringZone.classList.add('disabled');
						// Give ICE a chance to recover (cancel any existing timeout first)
						if (iceRecoveryTimeout) clearTimeout(iceRecoveryTimeout);
						iceRecoveryTimeout = setTimeout(() => {
							iceRecoveryTimeout = null;
							if (controlPc && controlPc.iceConnectionState === 'disconnected') {
								console.log('ICE did not recover, reconnecting...');
								reconnectControl();
							}
						}, ICE_RECOVERY_TIMEOUT_MS);
					} else if (state === 'failed') {
						// Connection failed - reconnect
						console.error('Control connection failed');
						if (iceRecoveryTimeout) {
							clearTimeout(iceRecoveryTimeout);
							iceRecoveryTimeout = null;
						}
						isConnected = false;
						setStatus('disconnected', 'Connection Failed');
						throttleZone.classList.add('disabled');
						steeringZone.classList.add('disabled');
						reconnectControl();
					}
				};

				// Create unreliable, unordered DataChannel (UDP-like behavior)
				controlChannel = controlPc.createDataChannel('control', {
					ordered: false,
					maxRetransmits: 0,
				});

				controlChannel.binaryType = 'arraybuffer';

				controlChannel.onopen = () => {
					console.log('Control DataChannel open');
					isConnected = true;
					setStatus('connected', 'Connected');
					throttleZone.classList.remove('disabled');
					steeringZone.classList.remove('disabled');
					// Show waiting overlay until race starts
					waitingOverlay.classList.add('active');
					// Start 50Hz control loop
					controlInterval = setInterval(sendControl, CONTROL_INTERVAL_MS);
					// Start ping for latency measurement
					pingInterval = setInterval(sendPing, PING_INTERVAL_MS);
					updateTurboButton();
					updateTractionButton();
				};

				controlChannel.onmessage = (event) => {
					// Packet format: seq(2) + cmd(1) + payload...
					if (event.data instanceof ArrayBuffer) {
						const view = new DataView(event.data);
						if (view.byteLength >= 3) {
							const cmd = view.getUint8(2);

							// Handle PONG for latency measurement
							// Payload: timestamp(4) = total 7 bytes
							if (cmd === CMD_PONG && view.byteLength >= 7) {
								const sentTime = view.getUint32(3, true);
								const now = performance.now() & 0xffffffff;
								let rtt = now - sentTime;
								if (rtt < 0) rtt += 0x100000000;
								const oneWay = rtt / 2; // Input latency is one-way, not round-trip
								latency = latency === 0 ? oneWay : latency * 0.9 + oneWay * 0.1;
								latencyEl.textContent = `${Math.round(latency)}ms`;
							}
							// Handle race commands from admin
							// Payload: sub_cmd(1) = total 4 bytes
							else if (cmd === CMD_RACE && view.byteLength >= 4) {
								const subCmd = view.getUint8(3);
								handleRaceCommand(subCmd);
							}
							// Handle config commands (throttle limit)
							else if (cmd === CMD_CONFIG) {
								handleConfigCommand(event.data);
							}
							// Handle kick command
							else if (cmd === CMD_KICK) {
								handleKicked();
							}
							// Handle telemetry broadcast
							// Payload: race_time(4) + throttle(2) + steering(2) + lat(4) + lon(4) + speed(2) + heading(2) + fix(1) = 24 bytes total
							else if (cmd === CMD_TELEM && view.byteLength >= 24) {
								handleTelemetry(view);
							}
						}
					}
				};

				// Create offer
				const offer = await controlPc.createOffer();
				await controlPc.setLocalDescription(offer);

				// Wait for ICE gathering (with timeout)
				await new Promise((resolve) => {
					if (controlPc.iceGatheringState === 'complete') {
						resolve();
						return;
					}
					const timeout = setTimeout(() => {
						console.log('ICE gathering timeout, proceeding');
						resolve();
					}, ICE_GATHERING_TIMEOUT_MS);
					controlPc.onicegatheringstatechange = () => {
						if (controlPc.iceGatheringState === 'complete') {
							clearTimeout(timeout);
							resolve();
						}
					};
				});

				// Send offer to Pi relay
				const response = await fetch(`${CONTROL_URL}/control/offer?token=${encodeURIComponent(currentToken)}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/sdp' },
					body: controlPc.localDescription.sdp,
				});

				if (!response.ok) {
					const text = await response.text();
					throw new Error(text || `Signaling error: ${response.status}`);
				}

				const answerSdp = await response.text();
				await controlPc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

				console.log('Control channel signaling complete');
			}

			function stopControlChannel() {
				clearInterval(controlInterval);
				clearInterval(pingInterval);
				if (iceRecoveryTimeout) {
					clearTimeout(iceRecoveryTimeout);
					iceRecoveryTimeout = null;
				}
				if (controlChannel) {
					controlChannel.close();
					controlChannel = null;
				}
				if (controlPc) {
					controlPc.close();
					controlPc = null;
				}
				isConnected = false;
			}

			// Reconnect control channel after connection loss
			let reconnectAttempt = 0;

			async function reconnectControl() {
				stopControlChannel();

				// Exponential backoff: 1s, 2s, 4s, 8s... max 30s
				const delay = Math.min(1000 * Math.pow(2, reconnectAttempt), MAX_RECONNECT_DELAY_MS);
				reconnectAttempt++;

				console.log(`Reconnecting in ${delay / 1000}s (attempt ${reconnectAttempt})...`);
				setStatus('connecting', `Reconnecting (${reconnectAttempt})...`);

				await new Promise((r) => setTimeout(r, delay));

				// Check if device is reachable before attempting reconnect
				try {
					const res = await fetch(`${CONTROL_URL}/control/health`, { signal: AbortSignal.timeout(5000) });
					if (!res.ok) throw new Error('Health check failed');
				} catch (e) {
					console.log('Relay not reachable, retrying...');
					reconnectControl();
					return;
				}

				try {
					await startControlChannel();
					reconnectAttempt = 0; // Reset on success
					console.log('Reconnected successfully');
				} catch (err) {
					console.error('Reconnect failed:', err);
					reconnectControl();
				}
			}
			// ============================================

			async function connect(savedToken = null) {
				const token = savedToken || tokenInput.value.trim();
				if (!token) {
					loginError.textContent = 'Please enter a token';
					return;
				}

				currentToken = token;
				loginError.textContent = '';
				connectBtn.disabled = true;
				connectBtn.textContent = 'Connecting...';

				try {
					// Store token
					localStorage.setItem(TOKEN_STORAGE_KEY, currentToken);

					// Show control screen and start video
					showControlScreen();

					// Start control DataChannel
					await startControlChannel();
				} catch (err) {
					console.error('Connection error:', err);
					loginError.textContent = err.message || 'Connection failed';
					localStorage.removeItem(TOKEN_STORAGE_KEY);
					showLoginScreen();
				}
			}

			// Login button click
			connectBtn.addEventListener('click', () => connect());

			// Allow Enter key to submit
			tokenInput.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') connect();
			});

			// Auto-connect with saved token on page load
			const savedToken = localStorage.getItem(TOKEN_STORAGE_KEY);
			if (savedToken) {
				tokenInput.value = savedToken;
				// Small delay to let device status check complete
				setTimeout(() => connect(savedToken), 500);
			}

			// Throttle touch handling (vertical) - relative to touch origin
			function handleThrottleMove(clientY, origin) {
				const rect = throttleZone.getBoundingClientRect();
				const range = (rect.height - 80) / 2;
				let dy = origin - clientY;
				thrSlider = Math.max(-1, Math.min(1, dy / range));
				// Send raw throttle value - ESP32 enforces all safety limits
				thr = thrSlider;
				sendControl();
			}

			// Steering touch handling (horizontal) - relative to touch origin
			function handleSteeringMove(clientX, origin) {
				const rect = steeringZone.getBoundingClientRect();
				const range = (rect.width - 80) / 2;
				let dx = clientX - origin;
				str = Math.max(-1, Math.min(1, dx / range));
				sendControl();
			}

			// Touch events
			throttleZone.addEventListener('touchstart', (e) => {
				if (throttleTouchId === null) {
					const touch = e.changedTouches[0];
					throttleTouchId = touch.identifier;
					throttleTouchOrigin = touch.clientY;
					throttleZone.classList.add('active');
				}
				e.preventDefault();
			});

			steeringZone.addEventListener('touchstart', (e) => {
				if (steeringTouchId === null) {
					const touch = e.changedTouches[0];
					steeringTouchId = touch.identifier;
					steeringTouchOrigin = touch.clientX;
					steeringZone.classList.add('active');
				}
				e.preventDefault();
			});

			document.addEventListener('touchmove', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						handleThrottleMove(touch.clientY, throttleTouchOrigin);
					} else if (touch.identifier === steeringTouchId) {
						handleSteeringMove(touch.clientX, steeringTouchOrigin);
					}
				}
			});

			document.addEventListener('touchend', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						resetThrottle();
					} else if (touch.identifier === steeringTouchId) {
						resetSteering();
					}
				}
			});

			document.addEventListener('touchcancel', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						resetThrottle();
					} else if (touch.identifier === steeringTouchId) {
						resetSteering();
					}
				}
			});

			// Mouse support for desktop testing
			let mouseOnThrottle = false;
			let mouseOnSteering = false;

			throttleZone.addEventListener('mousedown', (e) => {
				mouseOnThrottle = true;
				mouseThrOrigin = e.clientY;
				throttleZone.classList.add('active');
				e.preventDefault();
			});

			steeringZone.addEventListener('mousedown', (e) => {
				mouseOnSteering = true;
				mouseStrOrigin = e.clientX;
				steeringZone.classList.add('active');
				e.preventDefault();
			});

			document.addEventListener('mousemove', (e) => {
				if (mouseOnThrottle) handleThrottleMove(e.clientY, mouseThrOrigin);
				if (mouseOnSteering) handleSteeringMove(e.clientX, mouseStrOrigin);
			});

			document.addEventListener('mouseup', () => {
				if (mouseOnThrottle) {
					mouseOnThrottle = false;
					resetThrottle();
				}
				if (mouseOnSteering) {
					mouseOnSteering = false;
					resetSteering();
				}
			});

			// Keyboard handling (WASD + Arrows) - use KeyboardEvent.code for layout-independent keys
			const KEY_UP = 'KeyW';
			const KEY_DOWN = 'KeyS';
			const KEY_LEFT = 'KeyA';
			const KEY_RIGHT = 'KeyD';
			const KEY_ARROW_UP = 'ArrowUp';
			const KEY_ARROW_DOWN = 'ArrowDown';
			const KEY_ARROW_LEFT = 'ArrowLeft';
			const KEY_ARROW_RIGHT = 'ArrowRight';
			const validKeys = [KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_ARROW_UP, KEY_ARROW_DOWN, KEY_ARROW_LEFT, KEY_ARROW_RIGHT];

			function updateFromKeys() {
				if (!isConnected) return;
				thrSlider =
					(keys.has(KEY_UP) || keys.has(KEY_ARROW_UP) ? keyStep : 0) + (keys.has(KEY_DOWN) || keys.has(KEY_ARROW_DOWN) ? -keyStep : 0);
				// Send raw throttle value - ESP32 enforces all safety limits
				thr = thrSlider;
				// Set target steering (actual str interpolates smoothly in the control loop)
				strTarget =
					(keys.has(KEY_RIGHT) || keys.has(KEY_ARROW_RIGHT) ? strStep : 0) +
					(keys.has(KEY_LEFT) || keys.has(KEY_ARROW_LEFT) ? -strStep : 0);
			}

			window.addEventListener('keydown', (e) => {
				if (validKeys.includes(e.code)) {
					keys.add(e.code);
					updateFromKeys();
					e.preventDefault();
				} else if (e.code === 'KeyE' && !e.repeat) {
					toggleTurbo();
					e.preventDefault();
				} else if (e.code === 'KeyQ' && !e.repeat) {
					toggleTraction();
					e.preventDefault();
				}
			});

			window.addEventListener('keyup', (e) => {
				if (keys.has(e.code)) {
					keys.delete(e.code);
					updateFromKeys();
					e.preventDefault();
				}
			});

			window.addEventListener('blur', () => {
				keys.clear();
				thrSlider = 0;
				thr = 0;
				str = 0;
				strTarget = 0;
				if (isConnected) sendControl();
			});

			// Handle tab visibility changes (covers mobile app switching, screen lock, etc.)
			// Browsers throttle timers for hidden tabs, so send neutral immediately
			document.addEventListener('visibilitychange', () => {
				if (document.hidden) {
					keys.clear();
					thrSlider = 0;
					thr = 0;
					str = 0;
					strTarget = 0;
					if (isConnected) sendControl();
				}
			});

			// Initialize thumbs position
			updateThumbs();

			// HUD clock for video latency measurement
			const hudClock = document.getElementById('hud-clock');
			function updateHudClock() {
				const now = new Date();
				const h = String(now.getHours()).padStart(2, '0');
				const m = String(now.getMinutes()).padStart(2, '0');
				const s = String(now.getSeconds()).padStart(2, '0');
				const ms = String(now.getMilliseconds()).padStart(3, '0');
				hudClock.textContent = `${h}:${m}:${s}.${ms}`;
				requestAnimationFrame(updateHudClock);
			}
			updateHudClock();
		</script>
	</body>
</html>
