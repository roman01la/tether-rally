<!doctype html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
		<link rel="shortcut icon" href="/icon_xs.png" />
		<title>Tether Rally</title>
		<style>
			:root {
				--color-success: #40916c;
				--color-success-light: #52b788;
				--color-success-dark: #2d6a4f;
				--color-error: #e63946;
				--color-warning: #e85d04;
				--color-turbo: #ff8c00;
				--color-turbo-border: #ffa500;
				--color-panel-bg: rgba(30, 30, 50, 0.7);
				--color-panel-hover: rgba(50, 50, 80, 0.8);
				--color-border: rgba(100, 100, 140, 0.5);
				--color-border-light: rgba(150, 150, 200, 0.5);
				--color-text-muted: rgba(255, 255, 255, 0.7);
				--color-bg-dark: #1a1a2e;
				--color-bg-darker: #16213e;
				--color-accent: #5a5a8a;
				--color-accent-light: #7a7aba;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
			}
			body {
				font-family: -apple-system, BlinkMacSystemFont, sans-serif;
				background: #000;
				color: #eee;
				height: 100vh;
				width: 100vw;
				user-select: none;
			}
			body.race-mode {
				overflow: hidden;
				touch-action: none;
			}
			/* Login screen */
			#login-screen {
				position: absolute;
				inset: 0;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: flex-start;
				gap: 20px;
				background: var(--color-bg-dark);
				z-index: 100;
				overflow-y: auto;
				padding: 20px;
			}
			#login-screen.hidden {
				display: none;
			}
			#login-screen h1 {
				font-size: 24px;
				font-weight: 300;
				color: #888;
			}
			#login-screen input {
				padding: 12px 20px;
				font-size: 16px;
				border: 2px solid #3a3a5a;
				border-radius: 10px;
				background: var(--color-bg-darker);
				color: #eee;
				width: 280px;
				text-align: center;
				font-family: monospace;
			}
			#login-screen input:focus {
				outline: none;
				border-color: #6a6a9a;
			}
			#login-screen button {
				padding: 12px 40px;
				font-size: 16px;
				border: none;
				border-radius: 10px;
				background: var(--color-success-dark);
				color: #eee;
				cursor: pointer;
				font-weight: 600;
			}
			#login-screen button:hover {
				background: var(--color-success);
			}
			#login-screen button:disabled {
				background: #3a3a5a;
				cursor: not-allowed;
			}
			#login-error {
				color: var(--color-error);
				font-size: 14px;
				min-height: 20px;
			}
			#device-status {
				font-size: 12px;
				color: #666;
				margin-top: -10px;
			}
			#device-status.online {
				color: var(--color-success);
			}
			.info-section {
				max-width: 400px;
				padding: 20px 20px 12px;
				background: var(--color-bg-darker);
				border-radius: 12px;
				text-align: left;
			}
			.info-section h2 {
				font-size: 16px;
				font-weight: 600;
				color: #eee;
				margin-bottom: 12px;
			}
			.info-section p {
				font-size: 14px;
				color: #888;
				line-height: 1.5;
				margin-bottom: 12px;
			}
			.info-section ul {
				margin: 0 0 12px 20px;
				font-size: 14px;
				color: #888;
				line-height: 1.6;
			}
			.info-section li {
				margin-bottom: 4px;
			}
			.info-section strong {
				color: #aaa;
			}
			.info-section .highlight {
				color: var(--color-success);
			}

			/* Control screen - racing game style */
			#control-screen {
				position: absolute;
				inset: 0;
				display: none;
			}
			#control-screen.active {
				display: block;
			}

			/* Video background */
			#video-container {
				position: absolute;
				inset: 0;
				background: #111;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#video-container canvas {
				position: absolute;
				width: 100%;
				height: 100%;
				object-fit: cover;
			}
			#video-placeholder {
				color: #555;
				font-size: 14px;
				text-transform: uppercase;
				letter-spacing: 3px;
				z-index: 1;
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 15px;
			}
			#video-placeholder .spinner {
				width: 30px;
				height: 30px;
				border: 3px solid rgba(255, 255, 255, 0.1);
				border-top-color: rgba(255, 255, 255, 0.5);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}
			#video-placeholder .spinner.hidden {
				display: none;
			}

			/* Controls disabled overlay */
			.control-zone.disabled {
				opacity: 0.3;
				pointer-events: none;
			}

			/* Hide touch controls when gamepad is connected */
			body.gamepad-connected .control-zone {
				display: none;
			}

			/* HUD overlay */
			#hud {
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				padding: 15px;
				gap: 20px;
				background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), transparent);
				pointer-events: none;
			}
			#status {
				padding: 6px 14px;
				border-radius: 20px;
				font-size: 12px;
				font-weight: 600;
			}
			#status.connected {
				background: rgba(45, 106, 79, 0.9);
			}
			#status.disconnected {
				background: rgba(157, 2, 8, 0.9);
			}
			#status.connecting {
				background: rgba(232, 93, 4, 0.9);
			}

			/* Shared control button styles */
			#control-buttons-container {
				position: absolute;
				bottom: 40px;
				left: 50%;
				transform: translateX(-50%);
				display: flex;
				gap: 15px;
				z-index: 20;
			}
			.control-btn {
				padding: 12px 24px;
				border-radius: 30px;
				border: 2px solid var(--color-border);
				background: var(--color-panel-bg);
				color: var(--color-text-muted);
				font-size: 14px;
				font-weight: 600;
				cursor: pointer;
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
				transition: all 0.2s;
			}
			.control-btn:hover {
				background: var(--color-panel-hover);
				border-color: var(--color-border-light);
			}
			.control-btn.disabled {
				opacity: 0.3;
				pointer-events: none;
			}
			#status.waiting {
				background: rgba(100, 100, 120, 0.9);
			}
			#values {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				min-width: 130px;
			}
			#latency {
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				min-width: 40px;
				text-align: right;
			}
			/* WiFi Signal Indicator (Pi's car WiFi) */
			#wifi-signal {
				display: flex;
				align-items: center;
				gap: 4px;
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
				font-variant-numeric: tabular-nums;
			}
			#wifi-signal .wifi-bars {
				display: flex;
				align-items: flex-end;
				gap: 2px;
				height: 14px;
			}
			#wifi-signal .wifi-bars .bar {
				width: 4px;
				background: rgba(255, 255, 255, 0.3);
				border-radius: 1px;
				transition:
					background 0.3s,
					height 0.3s;
			}
			#wifi-signal .wifi-bars .bar-1 {
				height: 4px;
			}
			#wifi-signal .wifi-bars .bar-2 {
				height: 7px;
			}
			#wifi-signal .wifi-bars .bar-3 {
				height: 10px;
			}
			#wifi-signal .wifi-bars .bar-4 {
				height: 14px;
			}
			#wifi-signal .wifi-bars .bar.active {
				background: rgba(0, 255, 0, 0.9);
			}
			#wifi-signal .wifi-bars .bar.active.warning {
				background: rgba(255, 200, 0, 0.9);
			}
			#wifi-signal .wifi-bars .bar.active.critical {
				background: rgba(255, 50, 50, 0.9);
			}
			#wifi-signal .wifi-dbm {
				min-width: 50px;
				text-align: right;
			}
			/* Connection Quality Indicators (Control & Video) */
			.connection-quality {
				display: flex;
				align-items: center;
				gap: 4px;
				font-size: 12px;
				color: rgba(255, 255, 255, 0.6);
				font-family: monospace;
				font-variant-numeric: tabular-nums;
			}
			.connection-quality .cq-icon {
				width: 14px;
				height: 14px;
				opacity: 0.7;
			}
			.connection-quality .cq-value {
				min-width: 32px;
				text-align: right;
			}
			.connection-quality .cq-value.good {
				color: rgba(0, 255, 0, 0.9);
			}
			.connection-quality .cq-value.warning {
				color: rgba(255, 200, 0, 0.9);
			}
			.connection-quality .cq-value.critical {
				color: rgba(255, 50, 50, 0.9);
			}
			.headlight-indicator {
				display: flex;
				align-items: center;
				margin-left: 8px;
			}
			.headlight-indicator img {
				width: 18px;
				height: 18px;
				opacity: 0.5;
				transition: opacity 0.2s;
			}
			.headlight-indicator.on img {
				opacity: 1;
			}
			#hud-clock {
				position: absolute;
				top: 23px;
				left: 15px;
				font-size: 12px;
				color: rgba(0, 255, 0, 0.9);
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				font-weight: bold;
				text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
				z-index: 20;
				pointer-events: none;
			}
			#turbo-btn.active {
				background: rgba(255, 140, 0, 0.9);
				border-color: var(--color-turbo-border);
				color: #000;
			}
			#assist-btn.active {
				background: rgba(0, 200, 100, 0.9);
				border-color: #00ff88;
				color: #000;
			}
			@keyframes turbo-pulse {
				0% {
					opacity: 0.8;
				}
				100% {
					opacity: 1;
				}
			}

			/* Video stats overlay */
			#video-stats {
				position: absolute;
				bottom: 10px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.6);
				padding: 6px 12px;
				border-radius: 4px;
				font-size: 11px;
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				color: rgba(255, 255, 255, 0.7);
				pointer-events: none;
				z-index: 10;
			}

			/* Control zones - positioned at bottom sides */
			.control-zone {
				position: absolute;
				bottom: 20px;
				width: 140px;
				height: 200px;
				background: rgba(30, 30, 50, 0.5);
				border-radius: 70px;
				border: 2px solid rgba(100, 100, 140, 0.3);
				display: flex;
				align-items: center;
				justify-content: center;
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
			}
			#throttle-zone {
				left: 20px;
			}
			#steering-zone {
				right: 20px;
				width: 220px;
				border-radius: 100px;
			}
			.control-zone .label {
				position: absolute;
				top: 12px;
				font-size: 10px;
				color: rgba(255, 255, 255, 0.3);
				text-transform: uppercase;
				letter-spacing: 2px;
			}

			/* Slider tracks */
			.slider-track {
				position: absolute;
				background: rgba(60, 60, 90, 0.5);
				border-radius: 8px;
			}
			#throttle-zone .slider-track {
				width: 8px;
				height: 120px;
			}
			#steering-zone .slider-track {
				height: 8px;
				width: 160px;
			}

			/* Thumbs */
			.slider-thumb {
				position: absolute;
				background: radial-gradient(circle at 30% 30%, rgba(150, 150, 200, 0.9), rgba(100, 100, 160, 0.9));
				border-radius: 50%;
				box-shadow:
					0 4px 20px rgba(0, 0, 0, 0.5),
					inset 0 1px 0 rgba(255, 255, 255, 0.2);
			}
			#throttle-thumb {
				width: 60px;
				height: 60px;
			}
			#steering-thumb {
				width: 60px;
				height: 60px;
			}

			/* Touch indicator when active */
			.control-zone.active {
				border-color: rgba(150, 150, 200, 0.5);
				background: rgba(40, 40, 70, 0.6);
			}

			#instructions {
				position: absolute;
				bottom: 240px;
				left: 0;
				right: 0;
				text-align: center;
				font-size: 11px;
				color: rgba(255, 255, 255, 0.2);
				pointer-events: none;
			}

			/* Shared fullscreen overlay styles */
			.fullscreen-overlay {
				position: absolute;
				inset: 0;
				display: none;
				align-items: center;
				justify-content: center;
				z-index: 50;
			}
			.fullscreen-overlay.active {
				display: flex;
			}

			/* Countdown overlay */
			#countdown-overlay {
				background: rgba(0, 0, 0, 0.7);
			}
			#countdown-number {
				font-size: 200px;
				font-weight: 700;
				color: #fff;
				text-shadow: 0 0 60px rgba(255, 255, 255, 0.5);
				animation: countdown-pulse 1s ease-out;
			}
			#countdown-number.go {
				color: #40916c;
				font-size: 120px;
			}
			@keyframes countdown-pulse {
				0% {
					transform: scale(1.5);
					opacity: 0;
				}
				50% {
					opacity: 1;
				}
				100% {
					transform: scale(1);
					opacity: 1;
				}
			}

			/* Race timer in HUD */
			#race-timer {
				padding: 6px 14px;
				border-radius: 20px;
				font-size: 14px;
				font-weight: 700;
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				background: rgba(0, 0, 0, 0.5);
				color: var(--color-success);
				display: none;
				min-width: 110px;
				text-align: center;
			}
			#race-timer.active {
				display: block;
			}

			/* Track map overlay */
			#track-map {
				position: absolute;
				top: 60px;
				right: 15px;
				max-width: 220px;
				background: rgba(0, 0, 0, 0.6);
				border-radius: 10px;
				overflow: hidden;
				pointer-events: none;
				display: none;
				z-index: 10;
			}
			#track-map.active {
				/* tmp disabled */
				/* display: block; */
			}
			#track-map img {
				display: block;
				width: 100%;
				height: auto;
				opacity: 0.8;
			}
			#track-map .car-dot {
				position: absolute;
				width: 18px;
				height: 18px;
				transform: translate(-50%, -50%);
				z-index: 1;
				filter: drop-shadow(0 0 4px rgba(255, 68, 68, 0.9));
			}
			#track-map .car-dot::before {
				content: '';
				position: absolute;
				inset: 0;
				background: #ff4444;
				clip-path: polygon(50% 0%, 100% 100%, 50% 70%, 0% 100%);
			}
			#track-map .no-fix {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				font-size: 10px;
				color: rgba(255, 255, 255, 0.5);
				text-transform: uppercase;
				letter-spacing: 1px;
			}
			#track-map .speed-display {
				position: absolute;
				bottom: 18px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 14px;
				font-weight: 700;
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				color: #fff;
				text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
				min-width: 70px;
				text-align: center;
			}
			#track-map .distance-display {
				position: absolute;
				bottom: 5px;
				left: 50%;
				transform: translateX(-50%);
				font-size: 11px;
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				color: rgba(255, 255, 255, 0.7);
				text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
				min-width: 55px;
				text-align: center;
			}

			/* Back camera picture-in-picture */
			#back-camera-pip {
				position: absolute;
				top: 60px;
				left: 15px;
				width: 220px;
				height: 140px;
				background: rgba(0, 0, 0, 0.8);
				border-radius: 10px;
				overflow: hidden;
				z-index: 10;
				display: none;
				border: 2px solid rgba(100, 100, 140, 0.5);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
			}
			#back-camera-pip.active {
				display: block;
			}
			#back-camera-pip canvas,
			#back-camera-pip video {
				width: 100%;
				height: 100%;
				object-fit: cover;
			}
			#back-camera-pip .pip-placeholder {
				position: absolute;
				inset: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				color: rgba(255, 255, 255, 0.4);
				font-size: 11px;
				text-transform: uppercase;
				letter-spacing: 1px;
			}
			#back-camera-pip .pip-placeholder .spinner {
				width: 20px;
				height: 20px;
				border: 2px solid rgba(255, 255, 255, 0.1);
				border-top-color: rgba(255, 255, 255, 0.4);
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin-right: 8px;
			}

			/* Video game style compass strip */
			#compass-hud {
				position: absolute;
				top: 50px;
				left: 50%;
				transform: translateX(-50%);
				width: 280px;
				height: 28px;
				background: rgba(0, 0, 0, 0.5);
				border-radius: 4px;
				overflow: hidden;
				pointer-events: none;
				z-index: 10;
				display: none;
			}
			#compass-hud.active {
				display: block;
			}
			#compass-strip {
				position: absolute;
				top: 0;
				height: 100%;
				display: flex;
				align-items: center;
				white-space: nowrap;
				font-family: monospace;
				font-size: 11px;
				font-weight: 600;
				color: rgba(255, 255, 255, 0.5);
				text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
				will-change: transform;
			}
			#compass-strip .cardinal {
				color: #fff;
				font-size: 13px;
				font-weight: 700;
				padding: 0 1px;
			}
			#compass-strip .cardinal.north {
				color: #ff4444;
			}
			#compass-strip .tick {
				display: inline-block;
				width: 1px;
				height: 8px;
				background: rgba(255, 255, 255, 0.25);
				margin: 0 11px;
			}
			#compass-strip .deg {
				padding: 0 2px;
				min-width: 24px;
				text-align: center;
			}
			#compass-center-mark {
				position: absolute;
				top: 0;
				left: 50%;
				transform: translateX(-50%);
				width: 2px;
				height: 100%;
				background: #ff4444;
				box-shadow: 0 0 6px rgba(255, 68, 68, 0.8);
			}
			#compass-heading {
				position: absolute;
				top: 100%;
				left: 50%;
				transform: translateX(-50%);
				margin-top: 2px;
				font-size: 11px;
				font-family: monospace;
				font-variant-numeric: tabular-nums;
				font-weight: 600;
				color: rgba(255, 255, 255, 0.7);
				text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
				min-width: 30px;
				text-align: center;
			}

			/* Race stopped overlay */
			#stopped-overlay {
				background: rgba(0, 0, 0, 0.8);
			}
			#stopped-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 20px;
			}
			#stopped-text {
				font-size: 60px;
				font-weight: 700;
				color: var(--color-error);
				text-shadow: 0 0 40px rgba(230, 57, 70, 0.5);
				animation: stopped-flash 0.5s ease-out;
			}
			#stopped-time {
				font-size: 72px;
				font-weight: 700;
				font-family: monospace;
				color: var(--color-success);
				text-shadow: 0 0 30px rgba(64, 145, 108, 0.5);
				animation: stopped-flash 0.5s ease-out 0.2s both;
			}
			@keyframes stopped-flash {
				0% {
					transform: scale(1.3);
					opacity: 0;
				}
				100% {
					transform: scale(1);
					opacity: 1;
				}
			}

			/* Waiting for race overlay */
			#waiting-overlay {
				background: rgba(0, 0, 0, 0.6);
				z-index: 45;
				pointer-events: none;
			}
			#waiting-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 15px;
			}
			#waiting-text {
				font-size: 28px;
				font-weight: 600;
				color: #888;
				text-transform: uppercase;
				letter-spacing: 4px;
			}
			#waiting-spinner {
				width: 40px;
				height: 40px;
				border: 3px solid rgba(255, 255, 255, 0.1);
				border-top-color: rgba(255, 255, 255, 0.5);
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}
			#ready-btn {
				padding: 20px 60px;
				font-size: 24px;
				font-weight: 700;
				border: none;
				border-radius: 16px;
				background: var(--color-success);
				color: white;
				cursor: pointer;
				text-transform: uppercase;
				letter-spacing: 3px;
				pointer-events: auto;
				margin-top: 20px;
				transition: all 0.2s ease;
				box-shadow: 0 4px 15px rgba(64, 145, 108, 0.4);
			}
			#ready-btn:hover:not(:disabled) {
				background: var(--color-success-light);
				transform: translateY(-2px);
				box-shadow: 0 6px 20px rgba(64, 145, 108, 0.5);
			}
			#ready-btn:active:not(:disabled) {
				transform: translateY(0);
			}
			#ready-btn:disabled {
				background: #555;
				color: #888;
				cursor: not-allowed;
				box-shadow: none;
			}

			/* Track Map Modal */
			#track-modal {
				position: fixed;
				inset: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				background: rgba(0, 0, 0, 0.85);
				z-index: 200;
			}
			#track-modal.hidden {
				display: none;
			}
			#track-modal-content {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 20px;
				max-width: 90vw;
				max-height: 90vh;
			}
			#track-modal-content img {
				max-width: 100%;
				max-height: 70vh;
				border-radius: 12px;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
			}
			#track-modal-content h2 {
				color: #eee;
				font-size: 24px;
				font-weight: 600;
			}
			#track-modal-actions {
				display: flex;
				gap: 15px;
				align-items: center;
			}
			#track-modal-close {
				padding: 12px 40px;
				font-size: 16px;
				border: none;
				border-radius: 10px;
				background: var(--color-success-dark);
				color: #eee;
				cursor: pointer;
				font-weight: 600;
			}
			#track-modal-close:hover {
				background: var(--color-success);
			}
			#track-modal-link {
				color: var(--color-accent);
				text-decoration: none;
				font-size: 14px;
			}
			#track-modal-link:hover {
				color: var(--color-accent-light);
				text-decoration: underline;
			}

			/* Debug Overlay Panels - split into left and right */
			.debug-panel {
				position: absolute;
				top: 210px;
				width: 260px;
				background: rgba(10, 10, 20, 0.85);
				border: 1px solid rgba(100, 100, 140, 0.4);
				border-radius: 8px;
				padding: 10px;
				font-family: monospace;
				font-size: 11px;
				color: #ccc;
				z-index: 30;
				backdrop-filter: blur(8px);
				-webkit-backdrop-filter: blur(8px);
				display: none;
				max-height: calc(100vh - 230px);
				overflow-y: auto;
			}
			#debug-overlay-left {
				left: 15px;
			}
			#debug-overlay-right {
				right: 15px;
			}
			.debug-panel.active {
				display: block;
			}
			.debug-panel h3 {
				margin: 0 0 8px 0;
				font-size: 12px;
				color: #888;
				text-transform: uppercase;
				letter-spacing: 1px;
				border-bottom: 1px solid rgba(100, 100, 140, 0.3);
				padding-bottom: 4px;
			}
			.debug-section {
				margin-bottom: 12px;
			}
			.debug-section-title {
				display: flex;
				align-items: center;
				gap: 6px;
				margin-bottom: 6px;
				font-weight: bold;
				font-size: 11px;
			}
			.debug-status-dot {
				width: 8px;
				height: 8px;
				border-radius: 50%;
				background: #444;
			}
			.debug-status-dot.idle {
				background: #3a5;
			}
			.debug-status-dot.active {
				background: #fa3;
			}
			.debug-status-dot.critical {
				background: #f33;
			}
			.debug-row {
				display: flex;
				justify-content: space-between;
				padding: 2px 0;
				border-bottom: 1px solid rgba(80, 80, 100, 0.2);
			}
			.debug-label {
				color: #888;
			}
			.debug-value {
				color: #ddd;
				text-align: right;
			}
			.debug-value.positive {
				color: #5f5;
			}
			.debug-value.negative {
				color: #f55;
			}
			.debug-value.warning {
				color: #fa3;
			}

			/* Throttle Pipeline Visualization */
			.throttle-pipeline {
				display: flex;
				align-items: center;
				gap: 4px;
				margin: 8px 0;
				font-size: 10px;
			}
			.pipeline-stage {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 2px;
			}
			.pipeline-bar {
				width: 30px;
				height: 60px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				position: relative;
				overflow: hidden;
			}
			.pipeline-fill {
				position: absolute;
				bottom: 0;
				left: 0;
				right: 0;
				background: linear-gradient(to top, #3a5, #5c7);
				transition: height 0.1s;
			}
			.pipeline-fill.cut {
				background: linear-gradient(to top, #a53, #c75);
			}
			.pipeline-label {
				font-size: 8px;
				color: #666;
				text-align: center;
				max-width: 32px;
			}
			.pipeline-arrow {
				color: #444;
				font-size: 14px;
			}

			/* Yaw Rate Comparison */
			.yaw-comparison {
				display: flex;
				align-items: center;
				gap: 8px;
				margin: 8px 0;
				padding: 6px;
				background: rgba(30, 30, 50, 0.6);
				border-radius: 4px;
			}
			.yaw-bar-container {
				flex: 1;
				height: 20px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				position: relative;
				overflow: hidden;
			}
			.yaw-center-line {
				position: absolute;
				left: 50%;
				top: 0;
				bottom: 0;
				width: 1px;
				background: #666;
			}
			.yaw-desired-marker {
				position: absolute;
				top: 2px;
				bottom: 2px;
				width: 3px;
				background: #5af;
				border-radius: 1px;
				transition: left 0.1s;
			}
			.yaw-actual-marker {
				position: absolute;
				top: 2px;
				bottom: 2px;
				width: 3px;
				background: #fa5;
				border-radius: 1px;
				transition: left 0.1s;
			}
			.yaw-label {
				font-size: 9px;
				color: #888;
				width: 40px;
				text-align: right;
			}
			.yaw-legend {
				display: flex;
				justify-content: center;
				gap: 12px;
				font-size: 9px;
				color: #888;
				margin-top: 4px;
			}
			.yaw-legend span {
				display: flex;
				align-items: center;
				gap: 4px;
			}
			.yaw-legend .dot-desired {
				width: 6px;
				height: 6px;
				background: #5af;
				border-radius: 1px;
			}
			.yaw-legend .dot-actual {
				width: 6px;
				height: 6px;
				background: #fa5;
				border-radius: 1px;
			}

			/* Slip Angle Gauge */
			.slip-gauge {
				display: flex;
				align-items: center;
				gap: 8px;
				margin: 8px 0;
			}
			.slip-gauge-arc {
				width: 80px;
				height: 44px;
				position: relative;
				overflow: hidden;
			}
			.slip-gauge-bg {
				position: absolute;
				bottom: 0;
				left: 0;
				width: 80px;
				height: 80px;
				border-radius: 50%;
				background: conic-gradient(from 180deg, #3a5 0deg, #3a5 55deg, #fa3 55deg, #fa3 70deg, #f33 70deg, #f33 90deg, transparent 90deg);
				opacity: 0.3;
			}
			.slip-gauge-needle {
				position: absolute;
				bottom: 4px;
				left: 50%;
				width: 2px;
				height: 36px;
				background: #fff;
				transform-origin: top center;
				transition: transform 0.1s;
				border-radius: 1px;
				margin-left: -1px;
			}
			.slip-gauge-center {
				position: absolute;
				top: 0;
				left: 50%;
				transform: translateX(-50%);
				width: 8px;
				height: 8px;
				background: #fff;
				border-radius: 50%;
			}
			.slip-gauge-value {
				font-size: 16px;
				font-weight: bold;
				min-width: 50px;
			}
			.slip-gauge-label {
				font-size: 9px;
				color: #888;
			}
			.slip-threshold-label {
				position: absolute;
				font-size: 7px;
				color: #666;
			}

			/* === NEW: ABS, Hill Hold, Coast, Surface Adaptation Styles === */

			/* ESC State Machine (for ABS) */
			.esc-state-machine {
				display: flex;
				gap: 4px;
				margin: 8px 0;
				font-size: 9px;
			}
			.esc-state {
				padding: 3px 6px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				color: #666;
				border: 1px solid transparent;
				transition: all 0.15s;
			}
			.esc-state.active {
				background: rgba(80, 120, 180, 0.6);
				color: #fff;
				border-color: #5af;
			}
			.esc-state-arrow {
				color: #444;
				align-self: center;
			}

			/* Direction Indicator */
			.direction-indicator {
				display: flex;
				align-items: center;
				gap: 6px;
				margin: 4px 0;
			}
			.direction-arrow {
				font-size: 16px;
				width: 24px;
				text-align: center;
			}
			.direction-arrow.forward {
				color: #5c7;
			}
			.direction-arrow.backward {
				color: #fa5;
			}
			.direction-arrow.stopped {
				color: #666;
			}

			/* ABS Badge */
			.abs-badge {
				display: inline-block;
				padding: 2px 8px;
				background: rgba(40, 40, 60, 0.8);
				border: 1px solid #444;
				border-radius: 4px;
				font-weight: bold;
				font-size: 10px;
				color: #666;
				margin-left: 8px;
			}
			.abs-badge.active {
				background: rgba(255, 80, 80, 0.4);
				border-color: #f55;
				color: #f88;
				animation: pulse-badge 0.3s ease-in-out infinite alternate;
			}
			@keyframes pulse-badge {
				from {
					opacity: 0.7;
				}
				to {
					opacity: 1;
				}
			}

			/* Pitch Gauge (for Hill Hold) */
			.pitch-gauge {
				display: flex;
				align-items: center;
				gap: 8px;
				margin: 8px 0;
			}
			.pitch-arc {
				width: 60px;
				height: 60px;
				position: relative;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 50%;
				overflow: hidden;
			}
			.pitch-horizon {
				position: absolute;
				left: 5%;
				right: 5%;
				top: 50%;
				height: 2px;
				background: linear-gradient(90deg, transparent 0%, #5af 50%, transparent 100%);
				transform-origin: center;
				transition: transform 0.15s;
			}
			.pitch-center-mark {
				position: absolute;
				left: 50%;
				top: 50%;
				width: 8px;
				height: 8px;
				margin: -4px 0 0 -4px;
				border: 2px solid #fa5;
				border-radius: 50%;
				background: transparent;
			}
			.pitch-value {
				font-size: 14px;
				font-weight: bold;
				min-width: 50px;
			}
			.pitch-value.uphill {
				color: #5c7;
			}
			.pitch-value.downhill {
				color: #fa5;
			}

			/* Hold Force Bar */
			.hold-force-bar {
				width: 100%;
				height: 16px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				position: relative;
				margin: 6px 0;
			}
			.hold-force-fill {
				position: absolute;
				top: 2px;
				bottom: 2px;
				left: 50%;
				background: #5af;
				border-radius: 2px;
				transition:
					width 0.1s,
					left 0.1s;
			}
			.hold-force-fill.positive {
				background: #5c7;
			}
			.hold-force-fill.negative {
				background: #fa5;
			}
			.hold-force-center {
				position: absolute;
				left: 50%;
				top: 0;
				bottom: 0;
				width: 1px;
				background: #666;
			}

			/* Grip Meter (for Surface Adaptation) */
			.grip-meter {
				display: flex;
				align-items: center;
				gap: 8px;
				margin: 8px 0;
			}
			.grip-bar {
				flex: 1;
				height: 16px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				position: relative;
				overflow: hidden;
			}
			.grip-fill {
				position: absolute;
				top: 2px;
				bottom: 2px;
				left: 2px;
				border-radius: 2px;
				transition:
					width 0.3s,
					background 0.3s;
			}
			.grip-fill.low {
				background: linear-gradient(90deg, #f33, #fa3);
			}
			.grip-fill.medium {
				background: linear-gradient(90deg, #fa3, #5c7);
			}
			.grip-fill.high {
				background: linear-gradient(90deg, #5c7, #3a5);
			}
			.grip-value {
				font-size: 12px;
				font-weight: bold;
				min-width: 40px;
				text-align: right;
			}

			/* Measuring Dot */
			.measuring-dot {
				width: 8px;
				height: 8px;
				border-radius: 50%;
				background: #444;
				margin-left: 6px;
			}
			.measuring-dot.active {
				background: #5af;
				animation: pulse-dot 0.5s ease-in-out infinite;
			}
			@keyframes pulse-dot {
				0%,
				100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.5;
					transform: scale(0.8);
				}
			}

			/* Coast Injection Bar */
			.coast-bar {
				width: 100%;
				height: 12px;
				background: rgba(40, 40, 60, 0.8);
				border-radius: 3px;
				position: relative;
				margin: 6px 0;
				overflow: hidden;
			}
			.coast-fill {
				position: absolute;
				top: 2px;
				bottom: 2px;
				left: 2px;
				background: linear-gradient(90deg, #5af, #58f);
				border-radius: 2px;
				transition: width 0.05s;
			}

			/* HOLD Badge (for Hill Hold) */
			.hold-badge {
				display: inline-block;
				padding: 2px 8px;
				background: rgba(40, 40, 60, 0.8);
				border: 1px solid #444;
				border-radius: 4px;
				font-weight: bold;
				font-size: 10px;
				color: #666;
				margin-left: 8px;
			}
			.hold-badge.active {
				background: rgba(90, 175, 255, 0.3);
				border-color: #5af;
				color: #8cf;
			}
		</style>
	</head>
	<body>
		<!-- Login Screen -->
		<div id="login-screen">
			<img src="logo.png" alt="Tether Rally" style="max-width: 340px; height: auto" />
			<input type="text" id="token-input" placeholder="Enter access token" autocomplete="off" />
			<div id="login-error"></div>
			<div id="device-status">Checking device...</div>
			<button id="connect-btn">Connect</button>
			<a href="/leaderboard.html" style="margin-top: 20px; color: #5a5a8a; text-decoration: none; font-size: 14px">üèÜ Leaderboard</a>

			<div class="info-section">
				<h2>üéÆ How It Works</h2>
				<p>
					Drive a <strong>real RC car</strong> remotely from your browser! You'll control an actual 1/10 scale vehicle via live video feed.
				</p>

				<h2>üì± Controls</h2>
				<ul>
					<li><strong>Gamepad (Steam Deck/Xbox):</strong> RT=gas, LT=brake, Left stick=steer</li>
					<li><strong>Mobile:</strong> Right stick steering, left trigger throttle</li>
					<li><strong>Desktop:</strong> Arrow keys or WASD</li>
				</ul>

				<h2>üèÅ What to Expect</h2>
				<ul>
					<li>Enter your access token to connect</li>
					<li>Wait for video feed to load</li>
					<li>Press <strong class="highlight">Ready</strong> when you're set</li>
					<li>Admin starts the race with countdown</li>
					<li>Complete the track as fast as you can!</li>
				</ul>
			</div>
		</div>

		<!-- Control Screen - Racing Game Style -->
		<div id="control-screen">
			<!-- Video Background -->
			<div id="video-container">
				<canvas id="fpv-canvas"></canvas>
				<div id="video-placeholder">
					<div class="spinner"></div>
					<span>Connecting video...</span>
				</div>
			</div>

			<!-- HUD Overlay -->
			<div id="hud">
				<div id="status" class="disconnected">Disconnected</div>
				<div id="race-timer">00:00.000</div>
				<div id="hud-clock">00:00:00</div>
				<div id="values">T: 0.000 | S: 0.000</div>
				<div id="latency">--ms</div>
				<div id="wifi-signal" title="Car WiFi Signal (Pi)">
					<span class="wifi-bars">
						<span class="bar bar-1"></span>
						<span class="bar bar-2"></span>
						<span class="bar bar-3"></span>
						<span class="bar bar-4"></span>
					</span>
					<span class="wifi-dbm">--dBm</span>
				</div>
				<div id="control-quality" class="connection-quality" title="Control Channel Quality">
					<img class="cq-icon" src="icons/controller.svg" alt="Control" />
					<span class="cq-value" id="control-lq">--%</span>
				</div>
				<div id="video-quality" class="connection-quality" title="Video Channel Quality">
					<img class="cq-icon" src="icons/video.svg" alt="Video" />
					<span class="cq-value" id="video-lq">--%</span>
				</div>
				<div id="headlight-status" class="headlight-indicator" title="Headlights">
					<img id="headlight-icon" src="icons/headlight_off.svg" alt="Headlight" />
				</div>
			</div>

			<!-- Compass HUD (video game style horizontal strip) -->
			<div id="compass-hud">
				<div id="compass-strip"></div>
				<div id="compass-center-mark"></div>
				<div id="compass-heading">0¬∞</div>
			</div>

			<!-- Track Map Overlay -->
			<div id="track-map">
				<img id="track-image" src="" alt="Track" />
				<div class="car-dot" id="car-dot"></div>
				<div class="no-fix" id="no-gps-fix">No GPS</div>
				<div class="speed-display" id="speed-display">0 km/h</div>
				<div class="distance-display" id="distance-display"></div>
			</div>

			<!-- Back Camera Picture-in-Picture -->
			<div id="back-camera-pip">
				<video id="back-camera-video" autoplay playsinline muted></video>
				<div class="pip-placeholder" id="back-camera-placeholder">
					<div class="spinner"></div>
					<span>Connecting...</span>
				</div>
			</div>

			<!-- Countdown Overlay -->
			<div id="countdown-overlay" class="fullscreen-overlay">
				<div id="countdown-number">3</div>
			</div>

			<!-- Race Stopped Overlay -->
			<div id="stopped-overlay" class="fullscreen-overlay">
				<div id="stopped-content">
					<div id="stopped-text">FINISH</div>
					<div id="stopped-time">00:00.000</div>
				</div>
			</div>

			<!-- Waiting for Race Overlay -->
			<div id="waiting-overlay" class="fullscreen-overlay">
				<div id="waiting-content">
					<div id="waiting-spinner"></div>
					<div id="waiting-text">Waiting for race</div>
					<button id="ready-btn" class="startable" disabled onclick="sendReady()">Ready</button>
				</div>
			</div>

			<!-- Video Stats -->
			<div id="video-stats"></div>

			<!-- Throttle (left side) -->
			<div id="throttle-zone" class="control-zone disabled">
				<div class="label">Throttle</div>
				<div class="slider-track"></div>
				<div id="throttle-thumb" class="slider-thumb"></div>
			</div>

			<!-- Steering (right side) -->
			<div id="steering-zone" class="control-zone disabled">
				<div class="label">Steering</div>
				<div class="slider-track"></div>
				<div id="steering-thumb" class="slider-thumb"></div>
			</div>

			<div id="instructions">üéÆ RT/LT=Gas/Brake LStick=Steer | ‚å®Ô∏è WASD | Q=Assist E=Turbo H=Light C=Debug</div>

			<!-- Control Buttons -->
			<div id="control-buttons-container">
				<button id="assist-btn" class="control-btn disabled" onclick="toggleAssist()" data-kb="ASSIST (Q)" data-gp="‚í∑ ASSIST">
					ASSIST (Q)
				</button>
				<button id="turbo-btn" class="control-btn disabled" onclick="toggleTurbo()" data-kb="TURBO (E)" data-gp="‚í∂ TURBO">TURBO (E)</button>
			</div>

			<!-- Debug Overlay -->
			<div id="debug-overlay-left" class="debug-panel">
				<h3>üîß Stability Debug</h3>

				<!-- Throttle Pipeline -->
				<div class="debug-section">
					<div class="debug-section-title">Throttle Pipeline</div>
					<div class="throttle-pipeline">
						<div class="pipeline-stage">
							<div class="pipeline-bar"><div class="pipeline-fill" id="pipe-input"></div></div>
							<div class="pipeline-label">Input</div>
						</div>
						<span class="pipeline-arrow">‚Üí</span>
						<div class="pipeline-stage">
							<div class="pipeline-bar"><div class="pipeline-fill" id="pipe-tc"></div></div>
							<div class="pipeline-label">TC</div>
						</div>
						<span class="pipeline-arrow">‚Üí</span>
						<div class="pipeline-stage">
							<div class="pipeline-bar"><div class="pipeline-fill" id="pipe-yrc"></div></div>
							<div class="pipeline-label">ESC</div>
						</div>
						<span class="pipeline-arrow">‚Üí</span>
						<div class="pipeline-stage">
							<div class="pipeline-bar"><div class="pipeline-fill" id="pipe-saw"></div></div>
							<div class="pipeline-label">Slip</div>
						</div>
						<span class="pipeline-arrow">‚Üí</span>
						<div class="pipeline-stage">
							<div class="pipeline-bar"><div class="pipeline-fill" id="pipe-final"></div></div>
							<div class="pipeline-label">Final</div>
						</div>
					</div>
				</div>

				<!-- Traction Control -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="tc-status-dot"></div>
						Traction Control
					</div>
					<div class="debug-row"><span class="debug-label">Slip Detected</span><span class="debug-value" id="tc-slip">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Phase</span><span class="debug-value" id="tc-phase">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Multiplier</span><span class="debug-value" id="tc-mult">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Wheel Accel</span><span class="debug-value" id="tc-wheel-accel">‚Äî</span></div>
					<div class="debug-row">
						<span class="debug-label">Vehicle Accel</span><span class="debug-value" id="tc-vehicle-accel">‚Äî</span>
					</div>
					<div class="debug-row"><span class="debug-label">Slip Ratio</span><span class="debug-value" id="tc-slip-ratio">‚Äî</span></div>
				</div>

				<!-- Yaw Rate Controller -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="yrc-status-dot"></div>
						Yaw Rate (ESC)
					</div>
					<div class="debug-row"><span class="debug-label">Intervention</span><span class="debug-value" id="yrc-intervention">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Multiplier</span><span class="debug-value" id="yrc-mult">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Virtual Brake</span><span class="debug-value" id="yrc-brake">‚Äî</span></div>
					<div class="yaw-comparison">
						<span class="yaw-label">Yaw ¬∞/s</span>
						<div class="yaw-bar-container">
							<div class="yaw-center-line"></div>
							<div class="yaw-desired-marker" id="yaw-desired"></div>
							<div class="yaw-actual-marker" id="yaw-actual"></div>
						</div>
					</div>
					<div class="yaw-legend">
						<span
							><div class="dot-desired"></div>
							Desired</span
						>
						<span
							><div class="dot-actual"></div>
							Actual</span
						>
					</div>
					<div class="debug-row"><span class="debug-label">Desired</span><span class="debug-value" id="yrc-desired">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Actual</span><span class="debug-value" id="yrc-actual">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Error</span><span class="debug-value" id="yrc-error">‚Äî</span></div>
				</div>

				<!-- Slip Detection (IMU-based) -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="saw-status-dot"></div>
						Slip Detection
					</div>
					<div class="slip-gauge">
						<div class="slip-gauge-arc">
							<div class="slip-gauge-bg"></div>
							<div class="slip-gauge-needle" id="slip-needle"></div>
							<div class="slip-gauge-center"></div>
						</div>
						<div>
							<div class="slip-gauge-value" id="saw-angle">0</div>
							<div class="slip-gauge-label">Lateral Excess (m/s¬≤)</div>
						</div>
					</div>
					<div class="debug-row"><span class="debug-label">Intervention</span><span class="debug-value" id="saw-intervention">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Multiplier</span><span class="debug-value" id="saw-mult">‚Äî</span></div>
				</div>

				<!-- Steering Shaper -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="ss-status-dot"></div>
						Steering Shaper
					</div>
					<div class="debug-row"><span class="debug-label">Limit</span><span class="debug-value" id="ss-limit">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Rate Limited</span><span class="debug-value" id="ss-rate">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Counter-Steer</span><span class="debug-value" id="ss-counter">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Assist Amount</span><span class="debug-value" id="ss-assist">‚Äî</span></div>
				</div>
			</div>

			<div id="debug-overlay-right" class="debug-panel">
				<h3>üîß Assist Systems</h3>
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="abs-status-dot"></div>
						ABS
						<span class="abs-badge" id="abs-badge">ABS</span>
					</div>
					<div class="debug-row">
						<span class="debug-label">ESC State</span>
						<div class="esc-state-machine">
							<span class="esc-state" id="esc-neutral">N</span>
							<span class="esc-state-arrow">‚Üí</span>
							<span class="esc-state" id="esc-braking">BRK</span>
							<span class="esc-state-arrow">‚Üí</span>
							<span class="esc-state" id="esc-armed">ARM</span>
							<span class="esc-state-arrow">‚Üí</span>
							<span class="esc-state" id="esc-reversing">REV</span>
						</div>
					</div>
					<div class="debug-row">
						<span class="debug-label">Direction</span>
						<div class="direction-indicator">
							<span class="direction-arrow" id="abs-direction">‚èπ</span>
							<span class="debug-value" id="abs-direction-text">stopped</span>
						</div>
					</div>
					<div class="debug-row"><span class="debug-label">Phase</span><span class="debug-value" id="abs-phase">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Slip Ratio</span><span class="debug-value" id="abs-slip-ratio">‚Äî</span></div>
				</div>

				<!-- Hill Hold -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="hh-status-dot"></div>
						Hill Hold
						<span class="hold-badge" id="hh-badge">HOLD</span>
					</div>
					<div class="pitch-gauge">
						<div class="pitch-arc">
							<div class="pitch-horizon" id="pitch-horizon"></div>
							<div class="pitch-center-mark"></div>
						</div>
						<div>
							<div class="pitch-value" id="hh-pitch">0¬∞</div>
							<div class="slip-gauge-label">Pitch</div>
						</div>
					</div>
					<div class="debug-row"><span class="debug-label">Hold Force</span><span class="debug-value" id="hh-force">‚Äî</span></div>
					<div class="hold-force-bar">
						<div class="hold-force-center"></div>
						<div class="hold-force-fill" id="hh-force-bar"></div>
					</div>
					<div class="debug-row"><span class="debug-label">Blend</span><span class="debug-value" id="hh-blend">‚Äî</span></div>
				</div>

				<!-- Coast Control -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="coast-status-dot"></div>
						Coast Control
					</div>
					<div class="debug-row"><span class="debug-label">Active</span><span class="debug-value" id="coast-active">‚Äî</span></div>
					<div class="debug-row"><span class="debug-label">Injection</span><span class="debug-value" id="coast-injection">‚Äî</span></div>
					<div class="coast-bar">
						<div class="coast-fill" id="coast-bar"></div>
					</div>
				</div>

				<!-- Surface Adaptation -->
				<div class="debug-section">
					<div class="debug-section-title">
						<div class="debug-status-dot" id="surface-status-dot"></div>
						Surface Adaptation
						<div class="measuring-dot" id="surface-measuring"></div>
					</div>
					<div class="grip-meter">
						<span class="debug-label">Grip</span>
						<div class="grip-bar">
							<div class="grip-fill" id="surface-grip-bar"></div>
						</div>
						<span class="grip-value" id="surface-grip">0.70</span>
					</div>
					<div class="debug-row">
						<span class="debug-label">Threshold √ó</span><span class="debug-value" id="surface-multiplier">‚Äî</span>
					</div>
				</div>
			</div>
		</div>

		<!-- Optional: Load config.js for deployment-specific URLs -->
		<script src="config.js" onerror="console.log('No config.js found, using defaults')"></script>

		<script>
			// ===== CONFIGURATION =====
			// These URLs should be configured for your deployment
			// For development, set DEV=true and update local URLs
			// For production, update the production URLs to match your domain
			const DEV = false;

			// Cloudflare Workers (static assets + TURN credentials)
			// Production: Your worker URL (e.g., https://your-app.workers.dev)
			const WORKER_URL = DEV ? 'http://localhost:8787' : window.WORKER_URL || window.location.origin;

			// FPV Camera (MediaMTX WHEP via Cloudflare Tunnel)
			// Production: Your camera tunnel URL (e.g., https://cam.yourdomain.com/cam/whep)
			const CAMERA_WHEP_URL = DEV ? 'http://pi.local:8889/cam/whep' : window.CAMERA_WHEP_URL || '';

			// Back Camera WHEP URL (for rear view PiP)
			// Production: Your back camera WHEP URL (e.g., https://cam.yourdomain.com/back/whep)
			const BACK_CAMERA_WHEP_URL = DEV ? '' : window.BACK_CAMERA_WHEP_URL || '';

			// Control Relay (WebRTC DataChannel signaling via Cloudflare Tunnel)
			// Production: Your control tunnel URL (e.g., https://control.yourdomain.com)
			const CONTROL_URL = DEV ? 'http://localhost:8890' : window.CONTROL_URL || '';
			// =========================

			// ===== TIMING CONSTANTS =====
			const CONTROL_INTERVAL_MS = 20; // 50Hz control loop
			const PING_INTERVAL_MS = 500;
			const DEVICE_CHECK_INTERVAL_MS = 5000;
			const ICE_RECOVERY_TIMEOUT_MS = 5000;
			const ICE_GATHERING_TIMEOUT_MS = 2000;
			const VIDEO_RECONNECT_DELAY_MS = 3000;
			const VIDEO_CHECK_DELAY_MS = 1000;
			const TURN_CREDENTIAL_REFRESH_MS = 12 * 60 * 60 * 1000; // 12 hours
			const MAX_RECONNECT_DELAY_MS = 30000;
			const COUNTDOWN_STEP_MS = 1000;
			const COUNTDOWN_GO_MS = 3000;
			const COUNTDOWN_HIDE_MS = 3500;
			const FINISH_DISPLAY_MS = 4000;
			const MINIMAL_MEASURED_VIDEO_LATENCY = 120; // ms
			// ============================

			// ===== PROTOCOL CONSTANTS =====

			const CMD_PING = 0x00;
			const CMD_CTRL = 0x01;
			const CMD_PONG = 0x02;
			const CMD_RACE = 0x03;
			const CMD_STATUS = 0x04;
			const CMD_CONFIG = 0x05;
			const CMD_KICK = 0x06; // Pi -> Browser: you have been kicked
			const CMD_TELEM = 0x07; // Pi -> Browser: telemetry broadcast
			const CMD_TURBO = 0x08; // Browser -> Pi: turbo mode toggle
			const CMD_TRACTION = 0x09; // Browser -> Pi: traction control toggle
			const CMD_STABILITY = 0x0a; // Browser -> Pi: stability control toggle
			const CMD_DEBUG_TELEM = 0x0b; // Pi -> Browser: debug telemetry (stability systems)
			const CMD_HEADLIGHT = 0x0c; // Browser -> Pi: headlight toggle
			const CMD_EXTENDED_TELEM = 0x0d; // Pi -> Browser: extended telemetry (ABS, Hill Hold, etc.)
			const CMD_ABS = 0x0e; // Browser -> Pi: ABS toggle
			const CMD_HILL_HOLD = 0x0f; // Browser -> Pi: hill hold toggle
			const CMD_COAST = 0x10; // Browser -> Pi: coast control toggle
			const CMD_SURFACE_ADAPT = 0x11; // Browser -> Pi: surface adaptation toggle

			// Race sub-commands
			const RACE_START_COUNTDOWN = 0x01;
			const RACE_STOP = 0x02;

			// Status sub-commands
			const STATUS_VIDEO = 0x01; // payload: 1 byte (0=disconnected, 1=connected)
			const STATUS_READY = 0x02; // payload: 1 byte (0=not ready, 1=ready)

			let playerReady = false;

			function sendVideoStatus(connected) {
				if (controlChannel && controlChannel.readyState === 'open') {
					const buf = new ArrayBuffer(5);
					const view = new DataView(buf);
					view.setUint16(0, 0, true); // seq=0 for status messages
					view.setUint8(2, CMD_STATUS);
					view.setUint8(3, STATUS_VIDEO);
					view.setUint8(4, connected ? 1 : 0);
					controlChannel.send(buf);
					console.log('Sent video status:', connected);
					// Enable ready button when video is connected
					if (connected && !playerReady) {
						readyBtn.disabled = false;
					}
				}
			}

			function sendReady() {
				if (controlChannel && controlChannel.readyState === 'open' && !playerReady) {
					const buf = new ArrayBuffer(5);
					const view = new DataView(buf);
					view.setUint16(0, 0, true);
					view.setUint8(2, CMD_STATUS);
					view.setUint8(3, STATUS_READY);
					view.setUint8(4, 1);
					controlChannel.send(buf);
					playerReady = true;
					readyBtn.textContent = '‚úì Ready';
					readyBtn.classList.add('ready');
					readyBtn.disabled = true;
					waitingText.textContent = 'Waiting for admin';
					console.log('Sent ready status');
				}
			}

			const TOKEN_STORAGE_KEY = 'tether-rally-token';
			let controlSeq = 0;

			let controlPc = null;
			let controlChannel = null;
			let pingInterval = null;
			let controlInterval = null;
			let currentToken = null;
			let thrSlider = 0;
			let thr = 0;
			let str = 0;
			let strTarget = 0; // Target steering for keyboard (for smooth interpolation)
			let latency = 0;
			let isConnected = false;
			let deviceOnline = false;
			let videoConnected = false;
			const keys = new Set();
			let turboMode = false; // Turbo mode state
			let tractionMode = false; // Traction control state
			let stabilityMode = false; // Stability (yaw-rate) control state
			let headlightMode = false; // Headlight state
			let absMode = false; // ABS state
			let hillHoldMode = false; // Hill hold state
			let coastMode = false; // Coast control state
			let surfaceAdaptMode = false; // Surface adaptation state
			let debugOverlayVisible = false; // Debug overlay visibility
			const keyStep = 1.0;
			const strStep = 1.0;
			const strSmoothRate = 0.15; // How fast steering interpolates (0-1, lower = smoother)

			// Gamepad state (Steam Deck / Xbox / PlayStation controllers)
			let gamepadConnected = false;
			let gamepadIndex = null;
			const gamepadDeadzone = 0.1; // Ignore small stick/trigger movements
			// Track previous button states for edge detection (toggle on press, not hold)
			let prevGamepadButtons = {};

			// Gamepad haptic feedback (vibration)
			// duration: ms, weakMagnitude/strongMagnitude: 0-1
			function vibrateGamepad(duration = 100, weakMagnitude = 0.5, strongMagnitude = 0.5) {
				if (!gamepadConnected || gamepadIndex === null) return;
				const gp = navigator.getGamepads()[gamepadIndex];
				if (!gp || !gp.vibrationActuator) return;
				try {
					gp.vibrationActuator.playEffect('dual-rumble', {
						startDelay: 0,
						duration: duration,
						weakMagnitude: weakMagnitude,
						strongMagnitude: strongMagnitude,
					});
				} catch (e) {
					// Vibration not supported or failed
				}
			}

			// Race state
			let raceStartTime = null;
			let raceTimerInterval = null;

			// GPS telemetry state
			let gpsLat = 0;
			let gpsLon = 0;
			let gpsSpeed = 0;
			let gpsHeading = 0;
			let gpsFix = false;

			// IMU telemetry state
			let imuHeading = 0; // Blended heading from IMU
			let imuCalibration = 0; // Packed calibration byte
			let yawRate = 0; // Yaw rate (deg/sec)
			let smoothedHeading = 0; // Client-side smoothed for rendering
			let compassBuilt = false; // Track if compass strip is built

			// Distance tracking (during race)
			let prevGpsLat = null;
			let prevGpsLon = null;
			let totalDistance = 0; // in meters (GPS-based, fallback)
			let wheelDistance = 0; // in meters (from wheel sensor, more accurate)
			let isRacing = false;

			// Track map configuration
			// Set these for each track: two opposite corners (SW and NE)
			let trackConfig = null;
			// Example:
			// trackConfig = {
			//   image: '/tracks/mytrack.png',
			//   sw: { lat: 1, lon: 1 },  // Southwest corner
			//   ne: { lat: 1, lon: 1 }   // Northeast corner
			// };

			// Debug telemetry state (stability systems)
			let debugTelem = {
				// Traction Control (LowSpeedTractionManager)
				tc: { slipDetected: false, phase: 0, throttleMult: 100, wheelAccel: 0, vehicleAccel: 0, slipRatio: 0 },
				// Yaw Rate Controller
				yrc: { intervention: 0, throttleMult: 100, virtualBrake: 0, yawDesired: 0, yawActual: 0, yawError: 0 },
				// Slip Angle Watchdog
				saw: { slipAngle: 0, intervention: false, throttleMult: 100 },
				// Steering Shaper
				ss: { steeringLimit: 100, rateLimited: false, counterSteer: false, counterAmount: 0 },
			};

			// Extended telemetry state (new controllers)
			let extendedTelem = {
				// ABS Controller
				abs: { active: false, direction: 0, phase: 0, slipRatio: 0, escState: 0 },
				// Hill Hold
				hh: { active: false, holdForce: 0, blend: 100, pitch: 0 },
				// Coast Control
				coast: { active: false, injection: 0 },
				// Surface Adaptation
				surface: { grip: 70, multiplier: 100, measuring: false },
				// WiFi Signal (Pi's car WiFi - for diagnosing car connectivity)
				wifi: { rssi: 0, linkQuality: 0 },
			};

			// Connection quality state (calculated client-side from RTT)
			let controlLQ = -1; // Control channel quality (0-100%), -1 = not measured
			let videoLQ = -1; // Video channel quality (0-100%), -1 = not measured
			let videoRttMs = 0; // Video channel RTT in ms (from WebRTC stats)

			// DOM elements
			const loginScreen = document.getElementById('login-screen');
			const controlScreen = document.getElementById('control-screen');
			const tokenInput = document.getElementById('token-input');
			const connectBtn = document.getElementById('connect-btn');
			const loginError = document.getElementById('login-error');
			const deviceStatusEl = document.getElementById('device-status');
			const fpvCanvas = document.getElementById('fpv-canvas');
			// Note: fpvCtx is created later - either transferred to worker or kept for fallback
			let fpvCtx = null;
			const videoPlaceholder = document.getElementById('video-placeholder');
			const statusEl = document.getElementById('status');
			const valuesEl = document.getElementById('values');
			const latencyEl = document.getElementById('latency');
			const throttleZone = document.getElementById('throttle-zone');
			const steeringZone = document.getElementById('steering-zone');
			const throttleThumb = document.getElementById('throttle-thumb');
			const steeringThumb = document.getElementById('steering-thumb');
			const countdownOverlay = document.getElementById('countdown-overlay');
			const countdownNumber = document.getElementById('countdown-number');
			const raceTimerEl = document.getElementById('race-timer');
			const stoppedOverlay = document.getElementById('stopped-overlay');
			const waitingOverlay = document.getElementById('waiting-overlay');
			const readyBtn = document.getElementById('ready-btn');
			const waitingText = document.getElementById('waiting-text');
			const turboBtn = document.getElementById('turbo-btn');

			// Back camera PiP elements
			const backCameraPip = document.getElementById('back-camera-pip');
			const backCameraVideo = document.getElementById('back-camera-video');
			const backCameraPlaceholder = document.getElementById('back-camera-placeholder');

			let throttleTouchId = null;
			let steeringTouchId = null;
			let throttleTouchOrigin = null;
			let steeringTouchOrigin = null;
			let mouseThrOrigin = null;
			let mouseStrOrigin = null;

			// ===== HELPER FUNCTIONS =====
			// Format milliseconds to MM:SS.mmm
			function formatTime(ms) {
				const mins = Math.floor(ms / 60000);
				const secs = Math.floor((ms % 60000) / 1000);
				const millis = ms % 1000;
				return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
			}

			// Create a binary packet with auto-incrementing sequence
			function createPacket(cmd, payloadSize = 0) {
				controlSeq = (controlSeq + 1) & 0xffff;
				const buf = new ArrayBuffer(3 + payloadSize);
				const view = new DataView(buf);
				view.setUint16(0, controlSeq, true);
				view.setUint8(2, cmd);
				return { buf, view };
			}

			// Reset throttle state
			function resetThrottle() {
				throttleTouchId = null;
				throttleTouchOrigin = null;
				mouseThrOrigin = null;
				throttleZone.classList.remove('active');
				thrSlider = 0;
				thr = 0;
				sendControl();
			}

			// Reset steering state
			function resetSteering() {
				steeringTouchId = null;
				steeringTouchOrigin = null;
				mouseStrOrigin = null;
				steeringZone.classList.remove('active');
				str = 0;
				sendControl();
			}
			// ============================

			// Check device status from control relay health endpoint
			async function checkDeviceStatus() {
				try {
					const res = await fetch(`${CONTROL_URL}/control/health`);
					const data = await res.json();
					deviceOnline = data.esp32_ip !== null;
					deviceStatusEl.textContent = deviceOnline ? 'üü¢ Device online' : 'üî¥ Device offline';
					deviceStatusEl.className = deviceOnline ? 'online' : '';
				} catch (e) {
					deviceStatusEl.textContent = '‚ö†Ô∏è Cannot reach relay';
					deviceOnline = false;
				}
			}

			// Check status on load and periodically
			checkDeviceStatus();
			setInterval(checkDeviceStatus, DEVICE_CHECK_INTERVAL_MS);

			// Load track config from window.TRACK_CONFIG if set in config.js
			if (window.TRACK_CONFIG) {
				setTrackConfig(window.TRACK_CONFIG);
			}

			function setStatus(state, text) {
				statusEl.className = state;
				statusEl.textContent = text;
			}

			function updateDisplay() {
				valuesEl.textContent = `T: ${thr.toFixed(3)} | S: ${str.toFixed(3)}`;
			}

			function updateWifiIndicator() {
				const rssi = extendedTelem.wifi.rssi;
				const lq = extendedTelem.wifi.linkQuality;

				// Update dBm text
				const dbmEl = document.querySelector('#wifi-signal .wifi-dbm');
				if (dbmEl) {
					dbmEl.textContent = `${rssi}dBm`;
				}

				// Update signal bars based on Pi's WiFi link quality (0-100%)
				// Bar thresholds: 1=25%, 2=50%, 3=75%, 4=100%
				const bars = document.querySelectorAll('#wifi-signal .wifi-bars .bar');
				const barThresholds = [0, 25, 50, 75]; // Minimum LQ for each bar

				// Determine signal state for coloring
				// Critical: LQ < 25%, Warning: LQ < 50%, Good: LQ >= 50%
				let signalState = 'good';
				if (lq < 25) signalState = 'critical';
				else if (lq < 50) signalState = 'warning';

				bars.forEach((bar, index) => {
					bar.classList.remove('active', 'warning', 'critical');
					if (lq >= barThresholds[index]) {
						bar.classList.add('active');
						if (signalState === 'warning') bar.classList.add('warning');
						if (signalState === 'critical') bar.classList.add('critical');
					}
				});
			}

			// Update control channel quality indicator
			// Called from PONG handler with one-way latency in ms
			function updateControlQuality(oneWayMs) {
				// 100% at ‚â§40ms one-way, 0% at ‚â•500ms
				if (oneWayMs <= 40) {
					controlLQ = 100;
				} else if (oneWayMs >= 500) {
					controlLQ = 0;
				} else {
					controlLQ = Math.round(100 - (oneWayMs - 40) / 4.6);
				}

				const el = document.getElementById('control-lq');
				if (el) {
					el.textContent = `${controlLQ}%`;
					el.classList.remove('good', 'warning', 'critical');
					if (controlLQ >= 75) el.classList.add('good');
					else if (controlLQ >= 50) el.classList.add('warning');
					else el.classList.add('critical');
				}
			}

			// Update video channel quality indicator
			// Called from updateVideoStats with RTT in ms
			function updateVideoQuality(rttMs) {
				videoRttMs = rttMs;
				// 100% at ‚â§140ms RTT, 0% at ‚â•500ms
				if (rttMs <= 140) {
					videoLQ = 100;
				} else if (rttMs >= 500) {
					videoLQ = 0;
				} else {
					videoLQ = Math.round(100 - (rttMs - 140) / 3.6);
				}

				const el = document.getElementById('video-lq');
				if (el) {
					el.textContent = `${videoLQ}%`;
					el.classList.remove('good', 'warning', 'critical');
					if (videoLQ >= 75) el.classList.add('good');
					else if (videoLQ >= 50) el.classList.add('warning');
					else el.classList.add('critical');
				}
			}

			// Reset video quality indicator when video disconnects
			function resetVideoQuality() {
				videoLQ = null;
				videoRttMs = null;
				const el = document.getElementById('video-lq');
				if (el) {
					el.textContent = '--%';
					el.classList.remove('good', 'warning', 'critical');
				}
			}

			function updateThumbs() {
				const thrZoneRect = throttleZone.getBoundingClientRect();
				const thrRange = (thrZoneRect.height - 80) / 2;
				throttleThumb.style.left = '50%';
				throttleThumb.style.top = `calc(50% - ${thrSlider * thrRange}px)`;
				throttleThumb.style.transform = 'translate(-50%, -50%)';

				const strZoneRect = steeringZone.getBoundingClientRect();
				const strRange = (strZoneRect.width - 80) / 2;
				steeringThumb.style.top = '50%';
				steeringThumb.style.left = `calc(50% + ${str * strRange}px)`;
				steeringThumb.style.transform = 'translate(-50%, -50%)';
			}

			function sendPing() {
				if (controlChannel && controlChannel.readyState === 'open') {
					// Packet: seq(2) + cmd(1) + timestamp(4) = 7 bytes
					const buf = new ArrayBuffer(7);
					const view = new DataView(buf);
					controlSeq = (controlSeq + 1) & 0xffff;
					view.setUint16(0, controlSeq, true);
					view.setUint8(2, CMD_PING);
					view.setUint32(3, performance.now() & 0xffffffff, true);
					controlChannel.send(buf);
				}
			}

			// Gamepad polling - called every control loop iteration
			// Steam Deck / Xbox layout:
			//   RT (index 7) = throttle (forward)
			//   LT (index 6) = brake/reverse
			//   Left stick X (axis 0) = steering
			//   A (0) = turbo, B (1) = traction, X (2) = stability, Y (3) = ABS
			//   LB (4) = hill hold, RB (5) = coast, D-pad up (12) = surface, D-pad down (13) = headlight
			function pollGamepad() {
				const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
				let gp = null;

				// Find the first connected gamepad
				for (let i = 0; i < gamepads.length; i++) {
					if (gamepads[i] && gamepads[i].connected) {
						gp = gamepads[i];
						if (gamepadIndex !== i) {
							gamepadIndex = i;
							gamepadConnected = true;
							console.log('Gamepad connected:', gp.id);
						}
						break;
					}
				}

				if (!gp) {
					if (gamepadConnected) {
						gamepadConnected = false;
						gamepadIndex = null;
						console.log('Gamepad disconnected');
					}
					return false; // No gamepad input
				}

				// Read triggers for throttle
				// RT (index 7) = forward throttle (0 to 1)
				// LT (index 6) = reverse/brake (0 to 1)
				const rt = gp.buttons[7] ? gp.buttons[7].value : 0;
				const lt = gp.buttons[6] ? gp.buttons[6].value : 0;

				// Calculate throttle: RT pushes forward, LT pushes backward
				let gpThrottle = rt - lt;

				// Apply deadzone
				if (Math.abs(gpThrottle) < gamepadDeadzone) gpThrottle = 0;

				// Read left stick X axis for steering (axis 0)
				// Positive = right, Negative = left
				let gpSteering = gp.axes[0] || 0;

				// Apply deadzone to steering
				if (Math.abs(gpSteering) < gamepadDeadzone) gpSteering = 0;

				// Always update throttle and steering from gamepad when connected
				// This ensures releasing the trigger returns throttle to 0 (like racing games)
				thrSlider = gpThrottle;
				thr = gpThrottle;
				str = gpSteering;
				strTarget = gpSteering; // Keep strTarget in sync for keyboard/gamepad switching

				// Check if gamepad has meaningful input (for return value)
				const hasInput = Math.abs(gpThrottle) > 0 || Math.abs(gpSteering) > 0;

				// Handle button presses for feature toggles (edge detection - only on press)
				// Button handling is intentionally separate from movement input - buttons should
				// always be processed even when the sticks/triggers are centered
				const buttonMappings = [
					{ index: 0, action: toggleTurbo }, // A = Turbo
					{ index: 1, action: toggleAssist }, // B = Assist (all stability features)
					{ index: 8, action: toggleDebugOverlay }, // Back/Select = Debug overlay
					{ index: 13, action: toggleHeadlight }, // D-pad Down = Headlight
					{ index: 9, action: clickStartable }, // Start/Menu = Click .startable button
				];

				for (const mapping of buttonMappings) {
					const btn = gp.buttons[mapping.index];
					if (btn) {
						const pressed = btn.pressed || btn.value > 0.5;
						const wasPressed = prevGamepadButtons[mapping.index] || false;
						// Trigger on rising edge (button just pressed)
						if (pressed && !wasPressed) {
							mapping.action();
						}
						prevGamepadButtons[mapping.index] = pressed;
					}
				}

				return hasInput;
			}

			function sendControl() {
				// Poll gamepad for input
				const gamepadActive = pollGamepad();

				// Smooth keyboard steering interpolation (only when using keyboard, not gamepad)
				if (!gamepadActive && (keys.size > 0 || str !== strTarget)) {
					str += (strTarget - str) * strSmoothRate;
					// Snap to target when very close
					if (Math.abs(str - strTarget) < 0.01) str = strTarget;
				}

				if (controlChannel && controlChannel.readyState === 'open') {
					// Packet: seq(2) + cmd(1) + thr(2) + str(2) = 7 bytes
					const buf = new ArrayBuffer(7);
					const view = new DataView(buf);
					controlSeq = (controlSeq + 1) & 0xffff;
					view.setUint16(0, controlSeq, true);
					view.setUint8(2, CMD_CTRL);
					view.setInt16(3, Math.round(thr * 32767), true);
					view.setInt16(5, Math.round(str * 32767), true);
					controlChannel.send(buf);
				}
				updateDisplay();
				updateThumbs();
			}

			function showLoginScreen() {
				loginScreen.classList.remove('hidden');
				controlScreen.classList.remove('active');
				document.body.classList.remove('race-mode');
				connectBtn.disabled = false;
				connectBtn.textContent = 'Connect';
				stopFpvStream();
				stopBackCameraStream();
				stopControlChannel();
			}

			function showControlScreen() {
				loginScreen.classList.add('hidden');
				controlScreen.classList.add('active');
				document.body.classList.add('race-mode');
				startFpvStream();
				// startBackCameraStream();
			}

			// ===== WebRTC FPV Stream with WebCodecs =====
			let fpvPeerConnection = null;
			let cachedIceServers = null;

			// Back camera PiP state
			let backCameraPeerConnection = null;
			let backCameraConnected = false;

			// WebCodecs decoder state (worker-based)
			let decoderWorker = null;
			let webCodecsSupported = 'VideoDecoder' in window && 'OffscreenCanvas' in window;
			let frameTimestamp = 0;

			// Stats tracking for WebCodecs
			let wcFrameCount = 0;
			let wcLastStatsTime = performance.now();
			let wcLastFrameTime = 0;
			let wcDecoderQueueSize = 0;
			let wcResolution = '';

			async function getIceServers() {
				// Use cached credentials if available and not expired
				if (cachedIceServers) {
					return cachedIceServers;
				}

				// Token is required to get TURN credentials
				if (!currentToken) {
					console.warn('No token available for TURN credentials, using STUN only');
					return [{ urls: 'stun:stun.l.google.com:19302' }];
				}

				try {
					const response = await fetch(`${WORKER_URL}/turn-credentials?token=${encodeURIComponent(currentToken)}`);
					if (response.ok) {
						const data = await response.json();
						cachedIceServers = data.iceServers;
						// Refresh credentials after 12 hours (they last 24h)
						setTimeout(() => {
							cachedIceServers = null;
						}, TURN_CREDENTIAL_REFRESH_MS);
						console.log('Got Cloudflare TURN credentials');
						return cachedIceServers;
					} else if (response.status === 401) {
						console.warn('Token invalid for TURN credentials, using STUN only');
					}
				} catch (err) {
					console.warn('Failed to get TURN credentials, falling back to STUN only:', err);
				}

				// Fallback to STUN only (won't work through NAT)
				return [{ urls: 'stun:stun.l.google.com:19302' }];
			}

			// ===== H.264 Processing (send to worker) =====
			function sendFrameToWorker(data, timestamp) {
				if (!decoderWorker) return;
				// Transfer the buffer to avoid copying
				const buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
				decoderWorker.postMessage(
					{
						type: 'frame',
						data: { buffer, timestamp },
					},
					[buffer],
				);
			}

			function createDecoderWorker() {
				if (!webCodecsSupported) {
					console.warn('WebCodecs or OffscreenCanvas not supported, falling back to standard WebRTC');
					return null;
				}

				try {
					const worker = new Worker('/video-decoder-worker.js');

					worker.onmessage = (event) => {
						const { type } = event.data;

						switch (type) {
							case 'ready':
								console.log('Decoder worker ready');
								break;

							case 'frame':
								// Frame was decoded and rendered
								wcFrameCount++;
								wcLastFrameTime = event.data.timestamp;

								// Mark video as connected on first frame
								if (!videoConnected) {
									videoPlaceholder.style.display = 'none';
									videoConnected = true;
									throttleZone.classList.remove('disabled');
									steeringZone.classList.remove('disabled');
									sendVideoStatus(true);
									if (!playerReady) {
										readyBtn.disabled = false;
									}
								}
								break;

							case 'stats':
								wcDecoderQueueSize = event.data.queueSize;
								if (event.data.width && event.data.height) {
									wcResolution = `${event.data.width}x${event.data.height}`;
								}
								break;

							case 'error':
								console.error('Decoder worker error:', event.data.message);
								break;
						}
					};

					worker.onerror = (e) => {
						console.error('Worker error:', e);
					};

					// Transfer canvas control to worker
					const offscreen = fpvCanvas.transferControlToOffscreen();
					worker.postMessage({ type: 'init', canvas: offscreen }, [offscreen]);

					return worker;
				} catch (e) {
					console.error('Failed to create decoder worker:', e);
					return null;
				}
			}

			// Setup Encoded Transform to intercept raw H.264 frames
			function setupEncodedStreams(receiver) {
				if (!receiver.createEncodedStreams) {
					console.warn('Encoded streams not supported');
					return false;
				}

				const { readable, writable } = receiver.createEncodedStreams();

				const transform = new TransformStream({
					transform: (encodedFrame, controller) => {
						// Get raw H.264 data and send to worker
						const data = new Uint8Array(encodedFrame.data);
						frameTimestamp += 16667; // ~60fps timestamp increment (in microseconds)
						sendFrameToWorker(data, frameTimestamp);

						// Don't pass to browser decoder - worker handles it
					},
				});

				readable
					.pipeThrough(transform)
					.pipeTo(writable)
					.catch((e) => {
						if (e.name !== 'AbortError') {
							console.error('Encoded stream error:', e);
						}
					});

				return true;
			}
			// =====================================

			async function startFpvStream() {
				if (fpvPeerConnection) {
					stopFpvStream();
				}

				// Reset WebCodecs state
				frameTimestamp = 0;
				wcFrameCount = 0;
				wcLastStatsTime = performance.now();
				wcLastFrameTime = 0;

				// Create decoder worker with OffscreenCanvas
				if (webCodecsSupported && !decoderWorker) {
					decoderWorker = createDecoderWorker();
				} else if (decoderWorker) {
					// Reset existing worker
					decoderWorker.postMessage({ type: 'reset' });
				}

				try {
					const iceServers = await getIceServers();
					fpvPeerConnection = new RTCPeerConnection({ iceServers });

					// Track whether we're using WebCodecs path
					let usingWebCodecs = false;

					fpvPeerConnection.ontrack = (event) => {
						console.log('Got track:', event.track.kind);

						if (event.track.kind === 'video') {
							// If we already set up encoded streams, we're done
							if (usingWebCodecs) {
								console.log('Using WebCodecs low-latency path');
								return;
							}

							// Fallback: Use standard video element (higher latency)
							console.log('WebCodecs not available, using fallback video element');
							setupFallbackVideo(event.streams[0], event.receiver);
						}
					};

					fpvPeerConnection.oniceconnectionstatechange = () => {
						const state = fpvPeerConnection.iceConnectionState;
						console.log('FPV ICE state:', state);
						if (state === 'disconnected' || state === 'failed') {
							// Check if we're still receiving frames
							const checkVideoPlaying = () => {
								// For WebCodecs, check if frames are still being decoded
								const timeSinceLastFrame = performance.now() - wcLastFrameTime;
								if (videoConnected && timeSinceLastFrame < 1000) {
									console.log('FPV ICE disconnected but frames still coming, ignoring');
									return;
								}
								// Video actually stopped
								videoPlaceholder.innerHTML = '<div class="spinner"></div><span>FPV Disconnected - Reconnecting...</span>';
								videoPlaceholder.style.display = 'flex';
								videoConnected = false;
								resetVideoQuality();
								sendVideoStatus(false);
							};

							setTimeout(checkVideoPlaying, VIDEO_CHECK_DELAY_MS);

							setTimeout(() => {
								if (
									!fpvPeerConnection ||
									fpvPeerConnection.iceConnectionState === 'disconnected' ||
									fpvPeerConnection.iceConnectionState === 'failed'
								) {
									console.log('Reconnecting FPV stream...');
									startFpvStream();
								}
							}, VIDEO_RECONNECT_DELAY_MS);
						} else if (state === 'connected' || state === 'completed') {
							if (videoConnected) {
								videoPlaceholder.style.display = 'none';
								sendVideoStatus(true);
							}
						}
					};

					// Add transceivers for receiving video/audio
					const videoTransceiver = fpvPeerConnection.addTransceiver('video', { direction: 'recvonly' });
					// fpvPeerConnection.addTransceiver('audio', { direction: 'recvonly' });

					// IMPORTANT: Set up encoded streams IMMEDIATELY after creating transceiver,
					// BEFORE any signaling happens. This is required by the API.
					if (webCodecsSupported && decoderWorker && videoTransceiver.receiver.createEncodedStreams) {
						try {
							usingWebCodecs = setupEncodedStreams(videoTransceiver.receiver);
							if (usingWebCodecs) {
								console.log('Encoded streams set up successfully');
							}
						} catch (e) {
							console.warn('Failed to set up encoded streams:', e);
							usingWebCodecs = false;
						}
					}

					// Create offer
					const offer = await fpvPeerConnection.createOffer();
					await fpvPeerConnection.setLocalDescription(offer);

					// Wait for ICE gathering with timeout
					await new Promise((resolve) => {
						if (fpvPeerConnection.iceGatheringState === 'complete') {
							resolve();
							return;
						}

						const timeout = setTimeout(() => {
							console.log('ICE gathering timeout, proceeding with available candidates');
							resolve();
						}, ICE_GATHERING_TIMEOUT_MS);

						fpvPeerConnection.onicegatheringstatechange = () => {
							if (fpvPeerConnection.iceGatheringState === 'complete') {
								clearTimeout(timeout);
								resolve();
							}
						};
					});

					// Send offer to MediaMTX WHEP endpoint
					const response = await fetch(CAMERA_WHEP_URL, {
						method: 'POST',
						headers: { 'Content-Type': 'application/sdp' },
						body: fpvPeerConnection.localDescription.sdp,
					});

					if (!response.ok) {
						throw new Error(`WHEP error: ${response.status}`);
					}

					// Set remote description from answer
					const answer = await response.text();
					await fpvPeerConnection.setRemoteDescription({
						type: 'answer',
						sdp: answer,
					});

					console.log('Video stream connected');
					startVideoStats();
				} catch (err) {
					console.error('Video stream error:', err);
					videoPlaceholder.innerHTML = '<span>FPV Unavailable</span>';
					videoPlaceholder.style.display = 'flex';
				}
			}

			// Fallback video element for browsers without WebCodecs/encoded streams
			let fallbackVideo = null;
			let fallbackCanvas = null;
			let fallbackCtx = null;

			function setupFallbackVideo(stream, receiver) {
				// Create a separate canvas for fallback mode
				// (main canvas may have been transferred to worker already)
				if (!fallbackCanvas) {
					fallbackCanvas = document.createElement('canvas');
					fallbackCanvas.style.position = 'absolute';
					fallbackCanvas.style.width = '100%';
					fallbackCanvas.style.height = '100%';
					fallbackCanvas.style.objectFit = 'cover';
					// Insert before the main canvas
					fpvCanvas.parentNode.insertBefore(fallbackCanvas, fpvCanvas);
					fpvCanvas.style.display = 'none';
					fallbackCtx = fallbackCanvas.getContext('2d');
				}

				// Create hidden video element for fallback
				if (!fallbackVideo) {
					fallbackVideo = document.createElement('video');
					fallbackVideo.autoplay = true;
					fallbackVideo.playsInline = true;
					fallbackVideo.muted = true;
					fallbackVideo.style.display = 'none';
					document.body.appendChild(fallbackVideo);
				}

				fallbackVideo.srcObject = stream;

				// Minimize jitter buffer
				if (receiver && 'playoutDelayHint' in receiver) {
					receiver.playoutDelayHint = 0;
				}

				// Draw video frames to canvas
				function drawFallback() {
					if (fallbackVideo && fallbackVideo.readyState >= 2) {
						if (fallbackCanvas.width !== fallbackVideo.videoWidth || fallbackCanvas.height !== fallbackVideo.videoHeight) {
							fallbackCanvas.width = fallbackVideo.videoWidth;
							fallbackCanvas.height = fallbackVideo.videoHeight;
						}
						fallbackCtx.drawImage(fallbackVideo, 0, 0);
						wcFrameCount++;
						wcLastFrameTime = performance.now();

						if (!videoConnected) {
							videoPlaceholder.style.display = 'none';
							videoConnected = true;
							throttleZone.classList.remove('disabled');
							steeringZone.classList.remove('disabled');
							sendVideoStatus(true);
							if (!playerReady) {
								readyBtn.disabled = false;
							}
						}
					}
					requestAnimationFrame(drawFallback);
				}
				requestAnimationFrame(drawFallback);

				// Skip to live edge
				fallbackVideo.onloadedmetadata = () => {
					if (fallbackVideo.buffered.length > 0) {
						fallbackVideo.currentTime = fallbackVideo.buffered.end(0);
					}
				};
			}

			// Video stats tracking
			let videoStatsInterval = null;
			let lastBytesReceived = 0;
			let lastStatsTime = 0;
			let lastPacketsReceived = 0;
			let lastPacketsLost = 0;
			let lastFramesDropped = 0;
			let connectionType = ''; // 'p2p' or 'relay'
			const videoStatsEl = document.getElementById('video-stats');

			async function updateVideoStats() {
				if (!fpvPeerConnection) return;

				try {
					const stats = await fpvPeerConnection.getStats();
					let bitrate = 0;
					let rttMs = 0;
					let resolution = '';
					let localCandidateId = null;
					let remoteCandidateId = null;

					// Diagnostic metrics
					let packetsReceived = 0;
					let packetsLost = 0;
					let jitter = 0;
					let framesDropped = 0;

					stats.forEach((report) => {
						if (report.type === 'inbound-rtp' && report.kind === 'video') {
							// Resolution
							if (report.frameWidth && report.frameHeight) {
								resolution = `${report.frameWidth}x${report.frameHeight}`;
							}

							// Bitrate (calculated from bytes received)
							const now = Date.now();
							if (lastStatsTime > 0 && report.bytesReceived) {
								const timeDelta = (now - lastStatsTime) / 1000;
								const bytesDelta = report.bytesReceived - lastBytesReceived;
								bitrate = Math.round((bytesDelta * 8) / timeDelta / 1000); // kbps
							}
							lastBytesReceived = report.bytesReceived || 0;
							lastStatsTime = now;

							// Diagnostic metrics
							packetsReceived = report.packetsReceived || 0;
							packetsLost = report.packetsLost || 0;
							jitter = report.jitter ? Math.round(report.jitter * 1000) : 0;
							framesDropped = report.framesDropped || 0;
						}

						// RTT and candidate IDs from candidate pair
						if (report.type === 'candidate-pair' && report.state === 'succeeded') {
							if (report.currentRoundTripTime) {
								rttMs = Math.round(report.currentRoundTripTime * 1000);
							}
							localCandidateId = report.localCandidateId;
							remoteCandidateId = report.remoteCandidateId;
						}
					});

					// Determine connection type and log IPs from candidate types
					if (localCandidateId && remoteCandidateId && !connectionType) {
						let localCandidate = null;
						let remoteCandidate = null;
						stats.forEach((report) => {
							if (report.id === localCandidateId) {
								localCandidate = report;
								if (report.candidateType === 'relay') {
									connectionType = 'relay';
								}
							}
							if (report.id === remoteCandidateId) {
								remoteCandidate = report;
								if (report.candidateType === 'relay') {
									connectionType = 'relay';
								}
							}
						});
						if (!connectionType) {
							connectionType = 'p2p';
						}
						console.log(`Video connection type: ${connectionType}`);
						if (localCandidate) {
							console.log(`Video local candidate: ${localCandidate.candidateType} ${localCandidate.address || localCandidate.ip}`);
						}
						if (remoteCandidate) {
							console.log(`Video remote candidate: ${remoteCandidate.candidateType} ${remoteCandidate.address || remoteCandidate.ip}`);
						}
					}

					// Calculate FPS from our WebCodecs frame counter
					const now = performance.now();
					const elapsed = (now - wcLastStatsTime) / 1000;
					const fps = Math.round(wcFrameCount / elapsed);
					wcFrameCount = 0;
					wcLastStatsTime = now;

					// Calculate packet loss percentage for this interval
					const packetLossDelta = packetsLost - lastPacketsLost;
					const packetsReceivedDelta = packetsReceived - lastPacketsReceived;
					const framesDroppedDelta = framesDropped - lastFramesDropped;
					const totalPackets = packetLossDelta + packetsReceivedDelta;
					const lossPercent = totalPackets > 0 ? ((packetLossDelta / totalPackets) * 100).toFixed(1) : 0;

					// Update last values for next interval
					lastPacketsLost = packetsLost;
					lastPacketsReceived = packetsReceived;
					lastFramesDropped = framesDropped;

					// Update video quality indicator if we have RTT
					if (rttMs > 0) {
						updateVideoQuality(rttMs);
					}

					// Request stats from worker
					if (decoderWorker) {
						decoderWorker.postMessage({ type: 'getStats' });
					}

					const parts = [];
					parts.push(wcResolution || resolution || '---');
					parts.push(fps > 0 ? `${fps}fps` : '--fps');
					parts.push(bitrate > 0 ? `${bitrate}kbps` : '----kbps');
					parts.push(rttMs > 0 ? `${Math.round(rttMs / 2) + MINIMAL_MEASURED_VIDEO_LATENCY}ms` : '--ms');
					parts.push(`q:${wcDecoderQueueSize}`);
					parts.push(`j:${jitter}ms`);
					parts.push(`loss:${lossPercent}%`);
					parts.push(`drop:${framesDroppedDelta}`);

					videoStatsEl.textContent = parts.join(' ‚Ä¢ ');
				} catch (err) {
					// Ignore stats errors
				}
			}

			function startVideoStats() {
				stopVideoStats();
				lastBytesReceived = 0;
				lastStatsTime = 0;
				lastPacketsReceived = 0;
				lastPacketsLost = 0;
				lastFramesDropped = 0;
				wcFrameCount = 0;
				wcLastStatsTime = performance.now();
				videoStatsInterval = setInterval(updateVideoStats, 1000);
			}

			function stopVideoStats() {
				if (videoStatsInterval) {
					clearInterval(videoStatsInterval);
					videoStatsInterval = null;
				}
				videoStatsEl.textContent = '';
			}

			function stopFpvStream() {
				stopVideoStats();
				// Note: We don't terminate the worker on stop, just reset it
				// This avoids recreating OffscreenCanvas which can only be transferred once
				if (decoderWorker) {
					decoderWorker.postMessage({ type: 'reset' });
				}
				if (fpvPeerConnection) {
					fpvPeerConnection.close();
					fpvPeerConnection = null;
				}
				if (fallbackVideo) {
					fallbackVideo.srcObject = null;
				}
				videoConnected = false;
				resetVideoQuality();
				videoPlaceholder.innerHTML = '<div class="spinner"></div><span>Connecting video...</span>';
				videoPlaceholder.style.display = 'flex';
				throttleZone.classList.add('disabled');
				steeringZone.classList.add('disabled');
			}

			// ===== Back Camera PiP Stream =====
			async function startBackCameraStream() {
				if (!BACK_CAMERA_WHEP_URL) {
					console.log('Back camera URL not configured, skipping');
					return;
				}

				if (backCameraPeerConnection) {
					stopBackCameraStream();
				}

				// Show the PiP container
				backCameraPip.classList.add('active');
				backCameraPlaceholder.style.display = 'flex';
				backCameraVideo.style.display = 'none';

				try {
					const iceServers = await getIceServers();
					backCameraPeerConnection = new RTCPeerConnection({ iceServers });

					backCameraPeerConnection.ontrack = (event) => {
						console.log('Back camera track:', event.track.kind);
						if (event.track.kind === 'video') {
							backCameraVideo.srcObject = event.streams[0];
							backCameraVideo.style.display = 'block';
							backCameraPlaceholder.style.display = 'none';
							backCameraConnected = true;
							console.log('Back camera connected');

							// Minimize latency
							if (event.receiver && 'playoutDelayHint' in event.receiver) {
								event.receiver.playoutDelayHint = 0;
							}
						}
					};

					backCameraPeerConnection.oniceconnectionstatechange = () => {
						const state = backCameraPeerConnection.iceConnectionState;
						console.log('Back camera ICE state:', state);
						if (state === 'disconnected' || state === 'failed') {
							setTimeout(() => {
								if (
									backCameraPeerConnection &&
									(backCameraPeerConnection.iceConnectionState === 'disconnected' ||
										backCameraPeerConnection.iceConnectionState === 'failed')
								) {
									console.log('Reconnecting back camera...');
									startBackCameraStream();
								}
							}, VIDEO_RECONNECT_DELAY_MS);
						}
					};

					// Add transceiver for receiving video only
					backCameraPeerConnection.addTransceiver('video', { direction: 'recvonly' });

					// Create offer
					const offer = await backCameraPeerConnection.createOffer();
					await backCameraPeerConnection.setLocalDescription(offer);

					// Wait for ICE gathering
					await new Promise((resolve) => {
						if (backCameraPeerConnection.iceGatheringState === 'complete') {
							resolve();
							return;
						}

						const timeout = setTimeout(() => {
							console.log('Back camera ICE gathering timeout');
							resolve();
						}, ICE_GATHERING_TIMEOUT_MS);

						backCameraPeerConnection.onicegatheringstatechange = () => {
							if (backCameraPeerConnection.iceGatheringState === 'complete') {
								clearTimeout(timeout);
								resolve();
							}
						};
					});

					// Send offer to WHEP endpoint
					const response = await fetch(BACK_CAMERA_WHEP_URL, {
						method: 'POST',
						headers: { 'Content-Type': 'application/sdp' },
						body: backCameraPeerConnection.localDescription.sdp,
					});

					if (!response.ok) {
						throw new Error(`Back camera WHEP error: ${response.status}`);
					}

					const answer = await response.text();
					await backCameraPeerConnection.setRemoteDescription({
						type: 'answer',
						sdp: answer,
					});

					console.log('Back camera stream connected');
				} catch (err) {
					console.error('Back camera error:', err);
					backCameraPlaceholder.innerHTML = '<span>Rear cam unavailable</span>';
				}
			}

			function stopBackCameraStream() {
				if (backCameraPeerConnection) {
					backCameraPeerConnection.close();
					backCameraPeerConnection = null;
				}
				backCameraVideo.srcObject = null;
				backCameraConnected = false;
				backCameraPip.classList.remove('active');
				backCameraPlaceholder.innerHTML = '<div class="spinner"></div><span>Connecting...</span>';
			}
			// ==================================

			// =============================================

			// ===== Race Countdown & Timer =====
			function showCountdown() {
				countdownOverlay.classList.add('active');
				countdownNumber.textContent = '3';
				countdownNumber.className = '';
				// Vibrate on 3 - short pulse
				vibrateGamepad(150, 0.3, 0.3);

				setTimeout(() => {
					countdownNumber.textContent = '2';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
					// Vibrate on 2 - short pulse
					vibrateGamepad(150, 0.4, 0.4);
				}, COUNTDOWN_STEP_MS);

				setTimeout(() => {
					countdownNumber.textContent = '1';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
					// Vibrate on 1 - short pulse
					vibrateGamepad(150, 0.5, 0.5);
				}, COUNTDOWN_STEP_MS * 2);

				setTimeout(() => {
					countdownNumber.textContent = 'GO!';
					countdownNumber.className = 'go';
					countdownNumber.style.animation = 'none';
					countdownNumber.offsetHeight; // Trigger reflow
					countdownNumber.style.animation = '';
					// Vibrate on GO! - stronger, longer pulse
					vibrateGamepad(300, 0.8, 1.0);
				}, COUNTDOWN_GO_MS);

				setTimeout(() => {
					countdownOverlay.classList.remove('active');
					startRaceTimer();
				}, COUNTDOWN_HIDE_MS);
			}

			function startRaceTimer() {
				raceStartTime = Date.now();
				raceTimerEl.classList.add('active');

				if (raceTimerInterval) clearInterval(raceTimerInterval);
				raceTimerInterval = setInterval(updateRaceTimer, 50);
			}

			function updateRaceTimer() {
				if (!raceStartTime) return;
				const elapsed = Date.now() - raceStartTime;
				raceTimerEl.textContent = formatTime(elapsed);
			}

			function stopRaceTimer() {
				if (raceTimerInterval) {
					clearInterval(raceTimerInterval);
					raceTimerInterval = null;
				}
				raceStartTime = null;
				raceTimerEl.classList.remove('active');
			}

			function handleRaceCommand(subCmd) {
				console.log('Race command received:', subCmd);
				const RACE_RESUME = 0x03; // Reconnected during active race
				switch (subCmd) {
					case RACE_START_COUNTDOWN:
						stoppedOverlay.classList.remove('active'); // Hide stopped overlay if visible
						waitingOverlay.classList.remove('active'); // Hide waiting overlay
						// Reset distance tracking
						totalDistance = 0;
						wheelDistance = 0;
						prevGpsLat = null;
						prevGpsLon = null;
						isRacing = true;
						showCountdown();
						break;
					case RACE_RESUME:
						// Reconnected during active race - enable controls immediately
						console.log('Race resume - enabling controls');
						stoppedOverlay.classList.remove('active');
						waitingOverlay.classList.remove('active');
						countdownOverlay.classList.remove('active');
						isRacing = true;
						// Start timer from 0 (we don't know the actual elapsed time)
						raceStartTime = Date.now();
						raceTimerEl.classList.add('active');
						if (!raceTimerInterval) {
							raceTimerInterval = setInterval(updateRaceTimer, 50);
						}
						break;
					case RACE_STOP:
						isRacing = false;
						// Capture final time before stopping
						let finalTime = '00:00.000';
						if (raceStartTime) {
							const elapsed = Date.now() - raceStartTime;
							finalTime = formatTime(elapsed);
						}

						stopRaceTimer();
						countdownOverlay.classList.remove('active'); // Hide countdown if in progress

						// Show stopped overlay with final time
						document.getElementById('stopped-time').textContent = finalTime;
						stoppedOverlay.classList.add('active');
						setTimeout(() => {
							stoppedOverlay.classList.remove('active');
							waitingOverlay.classList.add('active'); // Show waiting overlay after finish fades
						}, FINISH_DISPLAY_MS); // Show longer so they can see the time
						break;
				}
			}

			function handleConfigCommand(data) {
				// Format: seq(2) + cmd(1) + reserved(1) + turbo(1) + traction(1) + stability(1) +
				//         abs(1) + hill_hold(1) + coast(1) + surface_adapt(1) = 11 bytes
				if (data.byteLength >= 6) {
					const view = new DataView(data);
					turboMode = view.getUint8(4) !== 0;
					tractionMode = view.getUint8(5) !== 0;
					if (data.byteLength >= 7) {
						stabilityMode = view.getUint8(6) !== 0;
					}
					if (data.byteLength >= 8) {
						absMode = view.getUint8(7) !== 0;
					}
					if (data.byteLength >= 9) {
						hillHoldMode = view.getUint8(8) !== 0;
					}
					if (data.byteLength >= 10) {
						coastMode = view.getUint8(9) !== 0;
					}
					if (data.byteLength >= 11) {
						surfaceAdaptMode = view.getUint8(10) !== 0;
					}
					updateTurboIndicator();
					updateAssistButton();
					console.log(
						'Config received: turbo =',
						turboMode,
						', traction =',
						tractionMode,
						', stability =',
						stabilityMode,
						', abs =',
						absMode,
						', hillHold =',
						hillHoldMode,
						', coast =',
						coastMode,
						', surface =',
						surfaceAdaptMode,
					);
				}
			}

			// ===== TOGGLE FEATURE FACTORY =====
			// Creates reusable toggle functions for turbo/traction-like features
			function createToggleFeature(name, cmd, btnEl) {
				return {
					updateIndicator(mode) {
						btnEl.classList.toggle('active', mode);
					},
					send(enabled) {
						if (controlChannel && controlChannel.readyState === 'open') {
							const { buf, view } = createPacket(cmd, 1);
							view.setUint8(3, enabled ? 1 : 0);
							controlChannel.send(buf);
							console.log(`Sent ${name}:`, enabled, 'seq:', controlSeq);
						}
					},
					updateButton() {
						btnEl.classList.toggle('disabled', !isConnected);
					},
				};
			}

			// Create send-only feature (no button element needed)
			function createSendOnlyFeature(name, cmd) {
				return {
					send(enabled) {
						if (controlChannel && controlChannel.readyState === 'open') {
							const { buf, view } = createPacket(cmd, 1);
							view.setUint8(3, enabled ? 1 : 0);
							controlChannel.send(buf);
							console.log(`Sent ${name}:`, enabled, 'seq:', controlSeq);
						}
					},
				};
			}

			// Create turbo toggle feature (has visible button)
			const turboFeature = createToggleFeature('turbo', CMD_TURBO, turboBtn);

			// Create stability features (controlled via combined Assist button)
			const tractionFeature = createSendOnlyFeature('traction', CMD_TRACTION);
			const stabilityFeature = createSendOnlyFeature('stability', CMD_STABILITY);
			const absFeature = createSendOnlyFeature('abs', CMD_ABS);
			const hillHoldFeature = createSendOnlyFeature('hillHold', CMD_HILL_HOLD);
			const coastFeature = createSendOnlyFeature('coast', CMD_COAST);
			const surfaceFeature = createSendOnlyFeature('surface', CMD_SURFACE_ADAPT);

			// Button update functions
			function updateTurboIndicator() {
				turboFeature.updateIndicator(turboMode);
			}
			function updateTurboButton() {
				turboFeature.updateButton();
			}
			function updateAssistButton() {
				const btn = document.getElementById('assist-btn');
				btn.classList.toggle('disabled', !isConnected);
				// Sync assistMode from individual features (any one enabled = assist on)
				assistMode = tractionMode || stabilityMode || absMode || hillHoldMode || coastMode || surfaceAdaptMode;
				updateAssistIndicator();
			}

			function toggleTurbo() {
				if (!isConnected) return;
				turboMode = !turboMode;
				turboFeature.send(turboMode);
				updateTurboIndicator();
			}

			// Combined assist toggle - enables/disables all stability features together
			let assistMode = false;

			function toggleAssist() {
				if (!isConnected) return;
				assistMode = !assistMode;
				// Set all stability features to the same state
				tractionMode = assistMode;
				stabilityMode = assistMode;
				absMode = assistMode;
				hillHoldMode = assistMode;
				coastMode = assistMode;
				surfaceAdaptMode = assistMode;
				// Send all feature states
				tractionFeature.send(tractionMode);
				stabilityFeature.send(stabilityMode);
				absFeature.send(absMode);
				hillHoldFeature.send(hillHoldMode);
				coastFeature.send(coastMode);
				surfaceFeature.send(surfaceAdaptMode);
				updateAssistIndicator();
			}

			function updateAssistIndicator() {
				const btn = document.getElementById('assist-btn');
				if (assistMode) {
					btn.classList.add('active');
				} else {
					btn.classList.remove('active');
				}
			}

			function toggleHeadlight() {
				if (!isConnected) return;
				headlightMode = !headlightMode;
				if (controlChannel && controlChannel.readyState === 'open') {
					const { buf, view } = createPacket(CMD_HEADLIGHT, 1);
					view.setUint8(3, headlightMode ? 1 : 0);
					controlChannel.send(buf);
					console.log('Sent headlight:', headlightMode);
				}
				updateHeadlightIndicator();
			}

			function updateHeadlightIndicator() {
				const indicator = document.getElementById('headlight-status');
				const icon = document.getElementById('headlight-icon');
				if (headlightMode) {
					indicator.classList.add('on');
					icon.src = 'icons/headlight_on.svg';
				} else {
					indicator.classList.remove('on');
					icon.src = 'icons/headlight_off.svg';
				}
			}

			function handleKicked() {
				console.log('Kicked by admin');
				// Stop everything
				stopFpvStream();
				stopControlChannel();
				// Reset ready state
				playerReady = false;
				readyBtn.textContent = 'Ready';
				readyBtn.classList.remove('ready');
				readyBtn.disabled = true;
				waitingText.textContent = 'Waiting for race';
				// Clear token so they can't auto-reconnect
				currentToken = null;
				// Show kicked message
				loginError.textContent = 'You have been kicked by the admin';
				loginError.style.display = 'block';
				// Go back to login screen
				showLoginScreen();
			}

			function handleTelemetry(view) {
				// Parse telemetry packet
				// Old format (24 bytes): seq(2) + cmd(1) + race_time(4) + throttle(2) + steering(2) + lat(4) + lon(4) + speed(2) + heading(2) + fix(1)
				// IMU format (29 bytes): + imu_heading(2) + calibration(1) + yaw_rate(2)
				// Wheel format (33 bytes): + wheel_distance(4)
				const raceTimeMs = view.getUint32(3, true);
				// const telem_throttle = view.getInt16(7, true);  // Not used currently
				// const telem_steering = view.getInt16(9, true);  // Not used currently
				gpsLat = view.getInt32(11, true) / 1e7; // Scaled lat back to degrees
				gpsLon = view.getInt32(15, true) / 1e7; // Scaled lon back to degrees
				gpsSpeed = view.getUint16(19, true) / 100; // Scaled speed back to km/h (now fused speed)
				gpsHeading = view.getUint16(21, true) / 100; // Scaled heading back to degrees
				gpsFix = view.getUint8(23) === 1;

				// Parse IMU fields if present (29+ byte format)
				if (view.byteLength >= 29) {
					imuHeading = view.getUint16(24, true) / 100; // Blended heading in degrees
					imuCalibration = view.getUint8(26); // Packed calibration
					yawRate = view.getInt16(27, true) / 100; // Yaw rate in deg/sec

					// Smooth heading for rendering (handles wrap-around)
					smoothedHeading = smoothAngle(smoothedHeading, imuHeading, 0.25);
				}

				// Parse wheel distance if present (33-byte format)
				if (view.byteLength >= 33) {
					wheelDistance = view.getUint32(29, true) / 100; // cm to meters
				}

				// Update track map and compass
				updateTrackMap();
				updateCompassHUD();
			}

			function handleDebugTelemetry(view) {
				// Parse debug telemetry packet (31 bytes total)
				// Format: seq(2) + cmd(1) + TC(9) + YRC(10) + SAW(4) + SS(5)

				// Traction Control (offset 3-11) - now uses LowSpeedTractionManager phases
				debugTelem.tc.slipDetected = view.getUint8(3) === 1;
				debugTelem.tc.phase = view.getUint8(4); // 0=none, 1=launch, 2=transition, 3=cruise
				debugTelem.tc.throttleMult = view.getUint8(5);
				debugTelem.tc.wheelAccel = view.getInt16(6, true) / 10;
				debugTelem.tc.vehicleAccel = view.getInt16(8, true) / 10;
				debugTelem.tc.slipRatio = view.getInt16(10, true) / 100;

				// Yaw Rate Controller (offset 12-21)
				debugTelem.yrc.intervention = view.getUint8(12);
				debugTelem.yrc.throttleMult = view.getUint8(13);
				debugTelem.yrc.virtualBrake = view.getUint16(14, true);
				debugTelem.yrc.yawDesired = view.getInt16(16, true) / 10;
				debugTelem.yrc.yawActual = view.getInt16(18, true) / 10;
				debugTelem.yrc.yawError = view.getInt16(20, true) / 10;

				// Slip Angle Watchdog (offset 22-25)
				debugTelem.saw.slipAngle = view.getInt16(22, true) / 10;
				debugTelem.saw.intervention = view.getUint8(24) === 1;
				debugTelem.saw.throttleMult = view.getUint8(25);

				// Steering Shaper (offset 26-30)
				debugTelem.ss.steeringLimit = view.getUint8(26);
				debugTelem.ss.rateLimited = view.getUint8(27) === 1;
				debugTelem.ss.counterSteer = view.getUint8(28) === 1;
				debugTelem.ss.counterAmount = view.getInt16(29, true);

				// Update debug overlay if visible
				if (debugOverlayVisible) {
					updateDebugOverlay();
				}
			}

			function handleExtendedTelemetry(view) {
				// Parse extended telemetry packet (25 bytes total)
				// Format: seq(2) + cmd(1) + ABS(6) + HH(6) + Coast(3) + Surface(5) + WiFi(2)

				// ABS Controller (offset 3-8)
				extendedTelem.abs.active = view.getUint8(3) === 1;
				extendedTelem.abs.direction = view.getUint8(4); // 0=stopped, 1=forward, 2=backward
				extendedTelem.abs.phase = view.getUint8(5); // 0=none, 1=apply, 2=release
				extendedTelem.abs.slipRatio = view.getInt16(6, true) / 100;
				extendedTelem.abs.escState = view.getUint8(8); // 0=neutral, 1=braking, 2=reverse_armed, 3=reversing

				// Hill Hold (offset 9-14)
				extendedTelem.hh.active = view.getUint8(9) === 1;
				extendedTelem.hh.holdForce = view.getInt16(10, true);
				extendedTelem.hh.blend = view.getUint8(12);
				extendedTelem.hh.pitch = view.getInt16(13, true) / 10;

				// Coast Control (offset 15-17)
				extendedTelem.coast.active = view.getUint8(15) === 1;
				extendedTelem.coast.injection = view.getInt16(16, true);

				// Surface Adaptation (offset 18-22)
				extendedTelem.surface.grip = view.getUint16(18, true) / 100;
				extendedTelem.surface.multiplier = view.getUint16(20, true) / 100;
				extendedTelem.surface.measuring = view.getUint8(22) === 1;

				// WiFi Signal (offset 23-24) - Pi's car WiFi for diagnosing car connectivity
				if (view.byteLength >= 25) {
					extendedTelem.wifi.rssi = view.getInt8(23); // Pi WiFi RSSI: -128 to 0 dBm
					extendedTelem.wifi.linkQuality = view.getUint8(24); // Pi WiFi link quality: 0-100%
					updateWifiIndicator();
				}

				// Update debug overlay if visible
				if (debugOverlayVisible) {
					updateExtendedDebugOverlay();
				}
			}

			function updateDebugOverlay() {
				const tc = debugTelem.tc;
				const yrc = debugTelem.yrc;
				const saw = debugTelem.saw;
				const ss = debugTelem.ss;

				// Calculate final throttle through pipeline (assumes 100% input for visualization)
				const inputPct = Math.abs(thr) * 100;
				const afterTc = inputPct * (tc.throttleMult / 100);
				const afterYrc = afterTc * (yrc.throttleMult / 100);
				const afterSaw = afterYrc * (saw.throttleMult / 100);

				// Update throttle pipeline bars
				document.getElementById('pipe-input').style.height = `${inputPct}%`;

				const pipeTc = document.getElementById('pipe-tc');
				pipeTc.style.height = `${afterTc}%`;
				pipeTc.className = `pipeline-fill${tc.throttleMult < 100 ? ' cut' : ''}`;

				const pipeYrc = document.getElementById('pipe-yrc');
				pipeYrc.style.height = `${afterYrc}%`;
				pipeYrc.className = `pipeline-fill${yrc.throttleMult < 100 ? ' cut' : ''}`;

				const pipeSaw = document.getElementById('pipe-saw');
				pipeSaw.style.height = `${afterSaw}%`;
				pipeSaw.className = `pipeline-fill${saw.throttleMult < 100 ? ' cut' : ''}`;

				document.getElementById('pipe-final').style.height = `${afterSaw}%`;

				// Traction Control section - now shows phases from LowSpeedTractionManager
				const tcDot = document.getElementById('tc-status-dot');
				if (!tractionMode) {
					tcDot.className = 'debug-status-dot';
				} else if (tc.slipDetected) {
					tcDot.className = 'debug-status-dot critical';
				} else if (tc.throttleMult < 100) {
					tcDot.className = 'debug-status-dot active';
				} else {
					tcDot.className = 'debug-status-dot idle';
				}

				const phaseNames = ['‚Äî', 'launch', 'transition', 'cruise'];
				document.getElementById('tc-slip').textContent = tc.slipDetected ? 'YES' : 'no';
				document.getElementById('tc-slip').className = `debug-value${tc.slipDetected ? ' negative' : ''}`;
				const phaseEl = document.getElementById('tc-phase');
				phaseEl.textContent = phaseNames[tc.phase] || '‚Äî';
				phaseEl.className = `debug-value${tc.phase === 1 ? ' warning' : ''}`; // highlight launch phase
				document.getElementById('tc-mult').textContent = `${tc.throttleMult}%`;
				document.getElementById('tc-mult').className = `debug-value${tc.throttleMult < 100 ? ' warning' : ''}`;
				document.getElementById('tc-wheel-accel').textContent = `${tc.wheelAccel.toFixed(1)} m/s¬≤`;
				document.getElementById('tc-vehicle-accel').textContent = `${tc.vehicleAccel.toFixed(1)} m/s¬≤`;
				document.getElementById('tc-slip-ratio').textContent = tc.slipRatio.toFixed(2);

				// Yaw Rate Controller section
				const yrcDot = document.getElementById('yrc-status-dot');
				if (!stabilityMode) {
					yrcDot.className = 'debug-status-dot';
				} else if (yrc.intervention === 1) {
					yrcDot.className = 'debug-status-dot critical'; // oversteer
				} else if (yrc.intervention === 2) {
					yrcDot.className = 'debug-status-dot active'; // understeer
				} else if (yrc.throttleMult < 100) {
					yrcDot.className = 'debug-status-dot active';
				} else {
					yrcDot.className = 'debug-status-dot idle';
				}

				const interventionNames = ['none', 'OVERSTEER', 'understeer'];
				const intEl = document.getElementById('yrc-intervention');
				intEl.textContent = interventionNames[yrc.intervention] || '‚Äî';
				intEl.className = `debug-value${yrc.intervention === 1 ? ' negative' : yrc.intervention === 2 ? ' warning' : ''}`;

				document.getElementById('yrc-mult').textContent = `${yrc.throttleMult}%`;
				document.getElementById('yrc-mult').className = `debug-value${yrc.throttleMult < 100 ? ' warning' : ''}`;
				document.getElementById('yrc-brake').textContent = yrc.virtualBrake > 0 ? yrc.virtualBrake : '‚Äî';
				document.getElementById('yrc-brake').className = `debug-value${yrc.virtualBrake > 0 ? ' negative' : ''}`;

				document.getElementById('yrc-desired').textContent = `${yrc.yawDesired.toFixed(1)}¬∞/s`;
				document.getElementById('yrc-actual').textContent = `${yrc.yawActual.toFixed(1)}¬∞/s`;
				document.getElementById('yrc-error').textContent = `${yrc.yawError.toFixed(1)}¬∞/s`;
				document.getElementById('yrc-error').className =
					`debug-value${Math.abs(yrc.yawError) > 35 ? ' negative' : Math.abs(yrc.yawError) > 20 ? ' warning' : ''}`;

				// Update yaw rate bar visualization (range: -100 to +100 deg/s mapped to 0-100%)
				// Negate so left turn shows indicator moving left
				const yawScale = 100; // +/- 100 deg/s full scale
				const desiredPos = 50 - (yrc.yawDesired / yawScale) * 50;
				const actualPos = 50 - (yrc.yawActual / yawScale) * 50;
				document.getElementById('yaw-desired').style.left = `${Math.max(0, Math.min(100, desiredPos))}%`;
				document.getElementById('yaw-actual').style.left = `${Math.max(0, Math.min(100, actualPos))}%`;

				// Slip Angle Watchdog section
				// Note: slipAngle now represents lateral_excess * 10 (so divide by 10 for m/s¬≤)
				const lateralExcess = saw.slipAngle / 10; // Convert to m/s¬≤
				const sawDot = document.getElementById('saw-status-dot');
				if (!stabilityMode) {
					sawDot.className = 'debug-status-dot';
				} else if (saw.intervention) {
					sawDot.className = 'debug-status-dot critical';
				} else if (Math.abs(lateralExcess) > 2.5) {
					sawDot.className = 'debug-status-dot active';
				} else {
					sawDot.className = 'debug-status-dot idle';
				}

				// Update slip gauge (0-6 m/s¬≤ mapped to 0-90¬∞ needle rotation)
				const absExcess = Math.abs(lateralExcess);
				const needleAngle = Math.min(90, absExcess * 15); // 6 m/s¬≤ = 90¬∞
				const needleDir = lateralExcess >= 0 ? 1 : -1;
				document.getElementById('slip-needle').style.transform = `rotate(${needleAngle * needleDir}deg)`;

				const angleEl = document.getElementById('saw-angle');
				angleEl.textContent = `${lateralExcess.toFixed(1)}`;
				angleEl.className = `slip-gauge-value${absExcess > 3.0 ? ' negative' : absExcess > 2.0 ? ' warning' : ''}`;

				document.getElementById('saw-intervention').textContent = saw.intervention ? 'ACTIVE' : 'no';
				document.getElementById('saw-intervention').className = `debug-value${saw.intervention ? ' negative' : ''}`;
				document.getElementById('saw-mult').textContent = `${saw.throttleMult}%`;
				document.getElementById('saw-mult').className = `debug-value${saw.throttleMult < 100 ? ' warning' : ''}`;

				// Steering Shaper section
				const ssDot = document.getElementById('ss-status-dot');
				if (!stabilityMode) {
					ssDot.className = 'debug-status-dot';
				} else if (ss.counterSteer) {
					ssDot.className = 'debug-status-dot active';
				} else if (ss.rateLimited) {
					ssDot.className = 'debug-status-dot active';
				} else {
					ssDot.className = 'debug-status-dot idle';
				}

				document.getElementById('ss-limit').textContent = `${ss.steeringLimit}%`;
				document.getElementById('ss-rate').textContent = ss.rateLimited ? 'YES' : 'no';
				document.getElementById('ss-rate').className = `debug-value${ss.rateLimited ? ' warning' : ''}`;
				document.getElementById('ss-counter').textContent = ss.counterSteer ? 'ACTIVE' : 'no';
				document.getElementById('ss-counter').className = `debug-value${ss.counterSteer ? ' positive' : ''}`;
				document.getElementById('ss-assist').textContent = ss.counterAmount !== 0 ? ss.counterAmount : '‚Äî';
			}

			function updateExtendedDebugOverlay() {
				const abs = extendedTelem.abs;
				const hh = extendedTelem.hh;
				const coast = extendedTelem.coast;
				const surface = extendedTelem.surface;

				// === ABS Section ===
				const absDot = document.getElementById('abs-status-dot');
				const absBadge = document.getElementById('abs-badge');
				if (!absMode) {
					absDot.className = 'debug-status-dot';
					absBadge.className = 'abs-badge';
				} else if (abs.active) {
					absDot.className = 'debug-status-dot critical';
					absBadge.className = 'abs-badge active';
				} else {
					absDot.className = 'debug-status-dot idle';
					absBadge.className = 'abs-badge';
				}

				// ESC State Machine
				const escStates = ['esc-neutral', 'esc-braking', 'esc-armed', 'esc-reversing'];
				escStates.forEach((id, idx) => {
					const el = document.getElementById(id);
					el.className = `esc-state${abs.escState === idx ? ' active' : ''}`;
				});

				// Direction indicator
				const dirArrow = document.getElementById('abs-direction');
				const dirText = document.getElementById('abs-direction-text');
				const dirNames = ['stopped', 'forward', 'backward'];
				const dirArrows = ['‚èπ', '‚¨Ü', '‚¨á'];
				const dirClasses = ['stopped', 'forward', 'backward'];
				dirArrow.textContent = dirArrows[abs.direction] || '‚èπ';
				dirArrow.className = `direction-arrow ${dirClasses[abs.direction] || 'stopped'}`;
				dirText.textContent = dirNames[abs.direction] || 'stopped';

				// ABS Phase
				const phaseEl = document.getElementById('abs-phase');
				const phaseNames = ['‚Äî', 'APPLY', 'RELEASE'];
				phaseEl.textContent = phaseNames[abs.phase] || '‚Äî';
				phaseEl.className = `debug-value${abs.phase === 1 ? ' warning' : abs.phase === 2 ? ' positive' : ''}`;

				// Slip ratio
				document.getElementById('abs-slip-ratio').textContent = abs.slipRatio.toFixed(2);

				// === Hill Hold Section ===
				const hhDot = document.getElementById('hh-status-dot');
				const hhBadge = document.getElementById('hh-badge');
				if (!hillHoldMode) {
					hhDot.className = 'debug-status-dot';
					hhBadge.className = 'hold-badge';
				} else if (hh.active) {
					hhDot.className = 'debug-status-dot active';
					hhBadge.className = 'hold-badge active';
				} else {
					hhDot.className = 'debug-status-dot idle';
					hhBadge.className = 'hold-badge';
				}

				// Pitch gauge (horizon rotates with pitch)
				const horizon = document.getElementById('pitch-horizon');
				const pitchClamped = Math.max(-30, Math.min(30, hh.pitch));
				horizon.style.transform = `rotate(${-pitchClamped}deg)`;

				// Pitch value
				const pitchEl = document.getElementById('hh-pitch');
				pitchEl.textContent = `${hh.pitch.toFixed(1)}¬∞`;
				pitchEl.className = `pitch-value${hh.pitch > 3 ? ' uphill' : hh.pitch < -3 ? ' downhill' : ''}`;

				// Hold force bar (centered, extends left or right)
				const forceBar = document.getElementById('hh-force-bar');
				const forceNormalized = (Math.abs(hh.holdForce) / 400) * 50; // Max 400 = 50% width
				forceBar.style.width = `${Math.min(50, forceNormalized)}%`;
				if (hh.holdForce >= 0) {
					forceBar.style.left = '50%';
					forceBar.className = 'hold-force-fill positive';
				} else {
					forceBar.style.left = `${50 - forceNormalized}%`;
					forceBar.className = 'hold-force-fill negative';
				}
				document.getElementById('hh-force').textContent = hh.holdForce;

				// Blend
				document.getElementById('hh-blend').textContent = `${hh.blend}%`;

				// === Coast Control Section ===
				const coastDot = document.getElementById('coast-status-dot');
				if (!coastMode) {
					coastDot.className = 'debug-status-dot';
				} else if (coast.active) {
					coastDot.className = 'debug-status-dot active';
				} else {
					coastDot.className = 'debug-status-dot idle';
				}

				document.getElementById('coast-active').textContent = coast.active ? 'ACTIVE' : 'no';
				document.getElementById('coast-active').className = `debug-value${coast.active ? ' positive' : ''}`;
				document.getElementById('coast-injection').textContent = coast.injection;

				// Coast bar
				const coastBar = document.getElementById('coast-bar');
				const injectionPct = Math.min(100, coast.injection);
				coastBar.style.width = `${injectionPct}%`;

				// === Surface Adaptation Section ===
				const surfaceDot = document.getElementById('surface-status-dot');
				const measuringDot = document.getElementById('surface-measuring');
				if (!surfaceAdaptMode) {
					surfaceDot.className = 'debug-status-dot';
					measuringDot.className = 'measuring-dot';
				} else if (surface.measuring) {
					surfaceDot.className = 'debug-status-dot active';
					measuringDot.className = 'measuring-dot active';
				} else {
					surfaceDot.className = 'debug-status-dot idle';
					measuringDot.className = 'measuring-dot';
				}

				// Grip bar (0.2 to 1.2 range)
				const gripBar = document.getElementById('surface-grip-bar');
				const gripPct = Math.max(0, Math.min(100, ((surface.grip - 0.2) / 1.0) * 100));
				gripBar.style.width = `${gripPct}%`;
				if (surface.grip < 0.5) {
					gripBar.className = 'grip-fill low';
				} else if (surface.grip < 0.8) {
					gripBar.className = 'grip-fill medium';
				} else {
					gripBar.className = 'grip-fill high';
				}

				const gripValue = document.getElementById('surface-grip');
				gripValue.textContent = surface.grip.toFixed(2);

				// Multiplier
				const multEl = document.getElementById('surface-multiplier');
				multEl.textContent = `${surface.multiplier.toFixed(1)}√ó`;
				multEl.className = `debug-value${surface.multiplier > 2.0 ? ' warning' : ''}`;
			}

			function toggleDebugOverlay() {
				debugOverlayVisible = !debugOverlayVisible;
				const overlayLeft = document.getElementById('debug-overlay-left');
				const overlayRight = document.getElementById('debug-overlay-right');
				if (debugOverlayVisible) {
					overlayLeft.classList.add('active');
					overlayRight.classList.add('active');
				} else {
					overlayLeft.classList.remove('active');
					overlayRight.classList.remove('active');
				}
			}

			// Click the first visible .startable button (for gamepad Start button navigation flow)
			function clickStartable() {
				const btn = document.querySelector('.startable:not(.hidden):not([disabled])');
				if (btn) {
					btn.click();
				}
			}

			// Smooth angle transition with wrap-around handling
			function smoothAngle(current, target, alpha) {
				const diff = Math.atan2(Math.sin(((target - current) * Math.PI) / 180), Math.cos(((target - current) * Math.PI) / 180));
				return (current + (alpha * diff * 180) / Math.PI + 360) % 360;
			}

			// Haversine formula to calculate distance between two GPS points (returns meters)
			function haversineDistance(lat1, lon1, lat2, lon2) {
				const R = 6371000; // Earth's radius in meters
				const dLat = ((lat2 - lat1) * Math.PI) / 180;
				const dLon = ((lon2 - lon1) * Math.PI) / 180;
				const a =
					Math.sin(dLat / 2) * Math.sin(dLat / 2) +
					Math.cos((lat1 * Math.PI) / 180) * Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				return R * c;
			}

			function updateTrackMap() {
				const trackMap = document.getElementById('track-map');
				const carDot = document.getElementById('car-dot');
				const noGpsFix = document.getElementById('no-gps-fix');
				const speedDisplay = document.getElementById('speed-display');
				const distanceDisplay = document.getElementById('distance-display');

				// Update speed display
				speedDisplay.textContent = `${Math.round(gpsSpeed)} km/h`;

				// Accumulate GPS distance as fallback (if wheel sensor not available)
				if (isRacing && gpsFix && prevGpsLat !== null && prevGpsLon !== null) {
					const dist = haversineDistance(prevGpsLat, prevGpsLon, gpsLat, gpsLon);
					// Filter out GPS jumps (> 10m between updates is suspicious at low speeds)
					if (dist < 10) {
						totalDistance += dist;
					}
				}
				if (gpsFix) {
					prevGpsLat = gpsLat;
					prevGpsLon = gpsLon;
				}

				// Update distance display - prefer wheel distance (more accurate), fallback to GPS
				const displayDistance = wheelDistance > 0 ? wheelDistance : totalDistance;
				if (displayDistance > 0) {
					distanceDisplay.textContent = `${(displayDistance / 1000).toFixed(2)} km`;
				} else {
					distanceDisplay.textContent = '';
				}

				// Show/hide GPS fix indicator
				if (!gpsFix) {
					noGpsFix.style.display = 'block';
					carDot.style.display = 'none';
					return;
				}

				noGpsFix.style.display = 'none';
				carDot.style.display = 'block';

				// If no track config, can't position the dot
				if (!trackConfig) {
					return;
				}

				// Check if coordinates are within track bounds
				const isOutOfBounds =
					gpsLat < trackConfig.sw.lat || gpsLat > trackConfig.ne.lat || gpsLon < trackConfig.sw.lon || gpsLon > trackConfig.ne.lon;

				if (isOutOfBounds) {
					carDot.style.display = 'none';
					return;
				}

				// Calculate position on map (0-100%)
				// Map GPS coordinates to pixel position within the track bounds
				const latRange = trackConfig.ne.lat - trackConfig.sw.lat;
				const lonRange = trackConfig.ne.lon - trackConfig.sw.lon;

				// Calculate percentage position (0-100)
				// X: longitude (left=0, right=100)
				// Y: latitude (bottom=0, top=100, but CSS top is inverted)
				const xPercent = ((gpsLon - trackConfig.sw.lon) / lonRange) * 100;
				const yPercent = 100 - ((gpsLat - trackConfig.sw.lat) / latRange) * 100; // Invert for CSS

				carDot.style.left = `${xPercent}%`;
				carDot.style.top = `${yPercent}%`;

				// Rotate arrow to show heading (0¬∞ = North = up)
				carDot.style.transform = `translate(-50%, -50%) rotate(${smoothedHeading}deg)`;
			}

			// Build compass strip HTML (called once)
			function buildCompassStrip(container) {
				// Build 1080¬∞ of compass (3x rotation for seamless infinite wrapping)
				// We display the middle 360¬∞ section and wrap around seamlessly
				const directions = {
					0: 'N',
					45: 'NE',
					90: 'E',
					135: 'SE',
					180: 'S',
					225: 'SW',
					270: 'W',
					315: 'NW',
				};

				let html = '';
				for (let deg = 0; deg < 1080; deg += 15) {
					const actualDeg = deg % 360;
					const dir = directions[actualDeg];

					if (dir) {
						// Cardinal or intercardinal
						const isNorth = actualDeg === 0;
						html += `<span class="cardinal${isNorth ? ' north' : ''}">${dir}</span>`;
					} else {
						// Degree number
						html += `<span class="deg">${actualDeg}</span>`;
					}
				}
				container.innerHTML = html;
			}

			// Update compass HUD display
			function updateCompassHUD() {
				const compassHUD = document.getElementById('compass-hud');
				const compassStrip = document.getElementById('compass-strip');
				const headingDisplay = document.getElementById('compass-heading');

				// Show compass when we have IMU data
				if (imuCalibration === 0 && !gpsFix) {
					compassHUD.classList.remove('active');
					return;
				}

				compassHUD.classList.add('active');

				// Build compass strip if not already done
				if (!compassBuilt) {
					buildCompassStrip(compassStrip);
					compassBuilt = true;
				}

				// Each 15¬∞ segment is about 25px wide
				// Strip total = 1080¬∞ = 72 segments, we show middle 360¬∞ section
				const pixelsPerDegree = 25 / 15; // ~1.67 px per degree
				const stripWidth360 = 360 * pixelsPerDegree; // Width of one full rotation

				// Start offset at middle section (360¬∞) so we have room to scroll either direction
				const baseOffset = stripWidth360; // Skip first 360¬∞ section
				const headingOffset = smoothedHeading * pixelsPerDegree;

				// Center the strip (140px = half of 280px container width)
				compassStrip.style.transform = `translateX(${140 - baseOffset - headingOffset}px)`;

				// Show numeric heading
				headingDisplay.textContent = `${Math.round(smoothedHeading)}¬∞`;
			}

			function setTrackConfig(config) {
				// Set track configuration and show the map
				// config = { image: '/tracks/mytrack.png', sw: {lat, lon}, ne: {lat, lon} }
				trackConfig = config;
				const trackMap = document.getElementById('track-map');
				const trackImage = document.getElementById('track-image');

				if (config) {
					trackImage.src = config.image;
					trackMap.classList.add('active');
				} else {
					trackMap.classList.remove('active');
				}
			}

			// ==================================

			// ===== WebRTC DataChannel for Controls =====
			let iceRecoveryTimeout = null; // Track the reconnect timeout

			async function startControlChannel() {
				const iceServers = await getIceServers();

				controlPc = new RTCPeerConnection({ iceServers });

				// Handle ICE connection state changes (including disconnection)
				controlPc.oniceconnectionstatechange = () => {
					console.log('Control ICE state:', controlPc.iceConnectionState);
					const state = controlPc.iceConnectionState;

					if (state === 'connected' || state === 'completed') {
						// Cancel any pending reconnect timeout
						if (iceRecoveryTimeout) {
							clearTimeout(iceRecoveryTimeout);
							iceRecoveryTimeout = null;
							console.log('ICE recovered, cancelled reconnect');
						}

						// Restore UI if DataChannel is still open
						if (controlChannel && controlChannel.readyState === 'open') {
							isConnected = true;
							setStatus('connected', 'Connected');
							throttleZone.classList.remove('disabled');
							steeringZone.classList.remove('disabled');
						}

						// Log the selected candidate pair
						controlPc.getStats().then((stats) => {
							stats.forEach((report) => {
								if (report.type === 'candidate-pair' && report.state === 'succeeded') {
									const localId = report.localCandidateId;
									const remoteId = report.remoteCandidateId;
									stats.forEach((r) => {
										if (r.id === localId) console.log('Control local candidate:', r.candidateType, r.address);
										if (r.id === remoteId) console.log('Control remote candidate:', r.candidateType, r.address);
									});
								}
							});
						});
					} else if (state === 'disconnected') {
						// Connection lost - update UI immediately
						console.warn('Control connection lost');
						isConnected = false;
						setStatus('disconnected', 'Connection Lost');
						throttleZone.classList.add('disabled');
						steeringZone.classList.add('disabled');
						// Give ICE a chance to recover (cancel any existing timeout first)
						if (iceRecoveryTimeout) clearTimeout(iceRecoveryTimeout);
						iceRecoveryTimeout = setTimeout(() => {
							iceRecoveryTimeout = null;
							if (controlPc && controlPc.iceConnectionState === 'disconnected') {
								console.log('ICE did not recover, reconnecting...');
								reconnectControl();
							}
						}, ICE_RECOVERY_TIMEOUT_MS);
					} else if (state === 'failed') {
						// Connection failed - reconnect
						console.error('Control connection failed');
						if (iceRecoveryTimeout) {
							clearTimeout(iceRecoveryTimeout);
							iceRecoveryTimeout = null;
						}
						isConnected = false;
						setStatus('disconnected', 'Connection Failed');
						throttleZone.classList.add('disabled');
						steeringZone.classList.add('disabled');
						reconnectControl();
					}
				};

				// Create unreliable, unordered DataChannel (UDP-like behavior)
				controlChannel = controlPc.createDataChannel('control', {
					ordered: false,
					maxRetransmits: 0,
				});

				controlChannel.binaryType = 'arraybuffer';

				controlChannel.onopen = () => {
					console.log('Control DataChannel open');
					isConnected = true;
					setStatus('connected', 'Connected');
					throttleZone.classList.remove('disabled');
					steeringZone.classList.remove('disabled');
					// Show waiting overlay until race starts
					waitingOverlay.classList.add('active');
					// Start 50Hz control loop
					controlInterval = setInterval(sendControl, CONTROL_INTERVAL_MS);
					// Start ping for latency measurement
					pingInterval = setInterval(sendPing, PING_INTERVAL_MS);
					updateTurboButton();
					updateAssistButton();
				};

				controlChannel.onmessage = (event) => {
					// Packet format: seq(2) + cmd(1) + payload...
					if (event.data instanceof ArrayBuffer) {
						const view = new DataView(event.data);
						if (view.byteLength >= 3) {
							const cmd = view.getUint8(2);

							// Handle PONG for latency measurement
							// Payload: timestamp(4) = total 7 bytes
							if (cmd === CMD_PONG && view.byteLength >= 7) {
								const sentTime = view.getUint32(3, true);
								const now = performance.now() & 0xffffffff;
								let rtt = now - sentTime;
								if (rtt < 0) rtt += 0x100000000;
								const oneWay = rtt / 2; // Input latency is one-way, not round-trip
								latency = latency === 0 ? oneWay : latency * 0.9 + oneWay * 0.1;
								latencyEl.textContent = `${Math.round(latency)}ms`;
								updateControlQuality(latency);
							}
							// Handle race commands from admin
							// Payload: sub_cmd(1) = total 4 bytes
							else if (cmd === CMD_RACE && view.byteLength >= 4) {
								const subCmd = view.getUint8(3);
								handleRaceCommand(subCmd);
							}
							// Handle config commands (throttle limit)
							else if (cmd === CMD_CONFIG) {
								handleConfigCommand(event.data);
							}
							// Handle kick command
							else if (cmd === CMD_KICK) {
								handleKicked();
							}
							// Handle telemetry broadcast
							// Payload: race_time(4) + throttle(2) + steering(2) + lat(4) + lon(4) + speed(2) + heading(2) + fix(1) = 24 bytes total
							else if (cmd === CMD_TELEM && view.byteLength >= 24) {
								handleTelemetry(view);
							}
							// Handle debug telemetry broadcast (stability systems)
							else if (cmd === CMD_DEBUG_TELEM && view.byteLength >= 31) {
								handleDebugTelemetry(view);
							}
							// Handle extended telemetry broadcast (ABS, Hill Hold, Coast, Surface)
							else if (cmd === CMD_EXTENDED_TELEM && view.byteLength >= 23) {
								handleExtendedTelemetry(view);
							}
						}
					}
				};

				// Create offer
				const offer = await controlPc.createOffer();
				await controlPc.setLocalDescription(offer);

				// Wait for ICE gathering (with timeout)
				await new Promise((resolve) => {
					if (controlPc.iceGatheringState === 'complete') {
						resolve();
						return;
					}
					const timeout = setTimeout(() => {
						console.log('ICE gathering timeout, proceeding');
						resolve();
					}, ICE_GATHERING_TIMEOUT_MS);
					controlPc.onicegatheringstatechange = () => {
						if (controlPc.iceGatheringState === 'complete') {
							clearTimeout(timeout);
							resolve();
						}
					};
				});

				// Send offer to Pi relay
				const response = await fetch(`${CONTROL_URL}/control/offer?token=${encodeURIComponent(currentToken)}`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/sdp' },
					body: controlPc.localDescription.sdp,
				});

				if (!response.ok) {
					const text = await response.text();
					throw new Error(text || `Signaling error: ${response.status}`);
				}

				const answerSdp = await response.text();
				await controlPc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

				console.log('Control channel signaling complete');
			}

			function stopControlChannel() {
				clearInterval(controlInterval);
				clearInterval(pingInterval);
				if (iceRecoveryTimeout) {
					clearTimeout(iceRecoveryTimeout);
					iceRecoveryTimeout = null;
				}
				if (controlChannel) {
					controlChannel.close();
					controlChannel = null;
				}
				if (controlPc) {
					controlPc.close();
					controlPc = null;
				}
				isConnected = false;
			}

			// Reconnect control channel after connection loss
			let reconnectAttempt = 0;

			async function reconnectControl() {
				stopControlChannel();

				// Exponential backoff: 1s, 2s, 4s, 8s... max 30s
				const delay = Math.min(1000 * Math.pow(2, reconnectAttempt), MAX_RECONNECT_DELAY_MS);
				reconnectAttempt++;

				console.log(`Reconnecting in ${delay / 1000}s (attempt ${reconnectAttempt})...`);
				setStatus('connecting', `Reconnecting (${reconnectAttempt})...`);

				await new Promise((r) => setTimeout(r, delay));

				// Check if device is reachable before attempting reconnect
				try {
					const res = await fetch(`${CONTROL_URL}/control/health`, { signal: AbortSignal.timeout(5000) });
					if (!res.ok) throw new Error('Health check failed');
				} catch (e) {
					console.log('Relay not reachable, retrying...');
					reconnectControl();
					return;
				}

				try {
					await startControlChannel();
					reconnectAttempt = 0; // Reset on success
					console.log('Reconnected successfully');
				} catch (err) {
					console.error('Reconnect failed:', err);
					reconnectControl();
				}
			}
			// ============================================

			async function connect(savedToken = null) {
				const token = savedToken || tokenInput.value.trim();
				if (!token) {
					loginError.textContent = 'Please enter a token';
					return;
				}

				currentToken = token;
				loginError.textContent = '';
				connectBtn.disabled = true;
				connectBtn.textContent = 'Connecting...';

				try {
					// Store token
					localStorage.setItem(TOKEN_STORAGE_KEY, currentToken);

					// Show control screen and start video
					showControlScreen();

					// Start control DataChannel
					await startControlChannel();
				} catch (err) {
					console.error('Connection error:', err);
					loginError.textContent = err.message || 'Connection failed';
					localStorage.removeItem(TOKEN_STORAGE_KEY);
					showLoginScreen();
				}
			}

			// Login button click
			connectBtn.addEventListener('click', () => connect());

			// Allow Enter key to submit
			tokenInput.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') connect();
			});

			// Auto-connect with saved token on page load
			const savedToken = localStorage.getItem(TOKEN_STORAGE_KEY);
			if (savedToken) {
				tokenInput.value = savedToken;
				// Small delay to let device status check complete
				setTimeout(() => connect(savedToken), 500);
			}

			// Throttle touch handling (vertical) - relative to touch origin
			function handleThrottleMove(clientY, origin) {
				const rect = throttleZone.getBoundingClientRect();
				const range = (rect.height - 80) / 2;
				let dy = origin - clientY;
				thrSlider = Math.max(-1, Math.min(1, dy / range));
				// Send raw throttle value - ESP32 enforces all safety limits
				thr = thrSlider;
				sendControl();
			}

			// Steering touch handling (horizontal) - relative to touch origin
			function handleSteeringMove(clientX, origin) {
				const rect = steeringZone.getBoundingClientRect();
				const range = (rect.width - 80) / 2;
				let dx = clientX - origin;
				str = Math.max(-1, Math.min(1, dx / range));
				sendControl();
			}

			// Touch events
			throttleZone.addEventListener('touchstart', (e) => {
				if (throttleTouchId === null) {
					const touch = e.changedTouches[0];
					throttleTouchId = touch.identifier;
					throttleTouchOrigin = touch.clientY;
					throttleZone.classList.add('active');
				}
				e.preventDefault();
			});

			steeringZone.addEventListener('touchstart', (e) => {
				if (steeringTouchId === null) {
					const touch = e.changedTouches[0];
					steeringTouchId = touch.identifier;
					steeringTouchOrigin = touch.clientX;
					steeringZone.classList.add('active');
				}
				e.preventDefault();
			});

			document.addEventListener('touchmove', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						handleThrottleMove(touch.clientY, throttleTouchOrigin);
					} else if (touch.identifier === steeringTouchId) {
						handleSteeringMove(touch.clientX, steeringTouchOrigin);
					}
				}
			});

			document.addEventListener('touchend', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						resetThrottle();
					} else if (touch.identifier === steeringTouchId) {
						resetSteering();
					}
				}
			});

			document.addEventListener('touchcancel', (e) => {
				for (const touch of e.changedTouches) {
					if (touch.identifier === throttleTouchId) {
						resetThrottle();
					} else if (touch.identifier === steeringTouchId) {
						resetSteering();
					}
				}
			});

			// Mouse support for desktop testing
			let mouseOnThrottle = false;
			let mouseOnSteering = false;

			throttleZone.addEventListener('mousedown', (e) => {
				mouseOnThrottle = true;
				mouseThrOrigin = e.clientY;
				throttleZone.classList.add('active');
				e.preventDefault();
			});

			steeringZone.addEventListener('mousedown', (e) => {
				mouseOnSteering = true;
				mouseStrOrigin = e.clientX;
				steeringZone.classList.add('active');
				e.preventDefault();
			});

			document.addEventListener('mousemove', (e) => {
				if (mouseOnThrottle) handleThrottleMove(e.clientY, mouseThrOrigin);
				if (mouseOnSteering) handleSteeringMove(e.clientX, mouseStrOrigin);
			});

			document.addEventListener('mouseup', () => {
				if (mouseOnThrottle) {
					mouseOnThrottle = false;
					resetThrottle();
				}
				if (mouseOnSteering) {
					mouseOnSteering = false;
					resetSteering();
				}
			});

			// Keyboard handling (WASD + Arrows) - use KeyboardEvent.code for layout-independent keys
			const KEY_UP = 'KeyW';
			const KEY_DOWN = 'KeyS';
			const KEY_LEFT = 'KeyA';
			const KEY_RIGHT = 'KeyD';
			const KEY_ARROW_UP = 'ArrowUp';
			const KEY_ARROW_DOWN = 'ArrowDown';
			const KEY_ARROW_LEFT = 'ArrowLeft';
			const KEY_ARROW_RIGHT = 'ArrowRight';
			const validKeys = [KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_ARROW_UP, KEY_ARROW_DOWN, KEY_ARROW_LEFT, KEY_ARROW_RIGHT];

			function updateFromKeys() {
				if (!isConnected) return;
				thrSlider =
					(keys.has(KEY_UP) || keys.has(KEY_ARROW_UP) ? keyStep : 0) + (keys.has(KEY_DOWN) || keys.has(KEY_ARROW_DOWN) ? -keyStep : 0);
				// Send raw throttle value - ESP32 enforces all safety limits
				thr = thrSlider;
				// Set target steering (actual str interpolates smoothly in the control loop)
				strTarget =
					(keys.has(KEY_RIGHT) || keys.has(KEY_ARROW_RIGHT) ? strStep : 0) +
					(keys.has(KEY_LEFT) || keys.has(KEY_ARROW_LEFT) ? -strStep : 0);
			}

			window.addEventListener('keydown', (e) => {
				if (validKeys.includes(e.code)) {
					keys.add(e.code);
					updateFromKeys();
					e.preventDefault();
				} else if (e.code === 'KeyE' && !e.repeat) {
					toggleTurbo();
					e.preventDefault();
				} else if (e.code === 'KeyQ' && !e.repeat) {
					toggleAssist();
					e.preventDefault();
				} else if (e.code === 'KeyC' && !e.repeat) {
					toggleDebugOverlay();
					e.preventDefault();
				} else if (e.code === 'KeyH' && !e.repeat) {
					toggleHeadlight();
					e.preventDefault();
				}
			});

			window.addEventListener('keyup', (e) => {
				if (keys.has(e.code)) {
					keys.delete(e.code);
					updateFromKeys();
					e.preventDefault();
				}
			});

			window.addEventListener('blur', () => {
				keys.clear();
				thrSlider = 0;
				thr = 0;
				str = 0;
				strTarget = 0;
				if (isConnected) sendControl();
			});

			// Handle tab visibility changes (covers mobile app switching, screen lock, etc.)
			// Browsers throttle timers for hidden tabs, so send neutral immediately
			document.addEventListener('visibilitychange', () => {
				if (document.hidden) {
					keys.clear();
					thrSlider = 0;
					thr = 0;
					str = 0;
					strTarget = 0;
					if (isConnected) sendControl();
				}
			});

			// Gamepad connect/disconnect event listeners
			window.addEventListener('gamepadconnected', (e) => {
				console.log('Gamepad connected event:', e.gamepad.id);
				gamepadIndex = e.gamepad.index;
				gamepadConnected = true;
				document.body.classList.add('gamepad-connected');
				updateButtonLabels(true);
			});

			window.addEventListener('gamepaddisconnected', (e) => {
				console.log('Gamepad disconnected event:', e.gamepad.id);
				if (gamepadIndex === e.gamepad.index) {
					gamepadIndex = null;
					gamepadConnected = false;
					prevGamepadButtons = {};
					document.body.classList.remove('gamepad-connected');
					updateButtonLabels(false);
				}
			});

			// Update control button labels for keyboard vs gamepad mode
			function updateButtonLabels(gamepadMode) {
				const buttons = document.querySelectorAll('#control-buttons-container .control-btn');
				buttons.forEach((btn) => {
					const label = gamepadMode ? btn.dataset.gp : btn.dataset.kb;
					if (label) btn.textContent = label;
				});
			}

			// Initialize thumbs position
			updateThumbs();

			// HUD clock for video latency measurement
			const hudClock = document.getElementById('hud-clock');
			function updateHudClock() {
				const now = new Date();
				const h = String(now.getHours()).padStart(2, '0');
				const m = String(now.getMinutes()).padStart(2, '0');
				const s = String(now.getSeconds()).padStart(2, '0');
				hudClock.textContent = `${h}:${m}:${s}`;
				requestAnimationFrame(updateHudClock);
			}
			updateHudClock();
		</script>
	</body>
</html>
