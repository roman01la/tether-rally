#include "url_prompt.h"

#ifdef __APPLE__
#define GL_SILENCE_DEPRECATION
#endif

#include <GLFW/glfw3.h>

#ifdef __APPLE__
#include <OpenGL/gl3.h>
#else
#include <GL/gl.h>
#endif

#include <iostream>
#include <cstring>
#include <algorithm>

// Simple bitmap font for rendering text (8x8 ASCII subset)
// Only includes characters needed for URL input
static const unsigned char font8x8[][8] = {
    // Space (32)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // ! (33) - through / (47) - punctuation
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    {0x6c, 0x6c, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    {0x6c, 0xfe, 0x6c, 0x6c, 0xfe, 0x6c, 0x00, 0x00}, // #
    {0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00}, // $
    {0x00, 0x66, 0xac, 0xd8, 0x36, 0x6a, 0xcc, 0x00}, // %
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00}, // &
    {0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    {0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00}, // (
    {0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00}, // )
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00}, // *
    {0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00}, // +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
    {0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00}, // -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00}, // /
    // 0-9 (48-57)
    {0x3c, 0x66, 0x6e, 0x7e, 0x76, 0x66, 0x3c, 0x00}, // 0
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00}, // 1
    {0x3c, 0x66, 0x06, 0x1c, 0x30, 0x60, 0x7e, 0x00}, // 2
    {0x3c, 0x66, 0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00}, // 3
    {0x0c, 0x1c, 0x3c, 0x6c, 0x7e, 0x0c, 0x0c, 0x00}, // 4
    {0x7e, 0x60, 0x7c, 0x06, 0x06, 0x66, 0x3c, 0x00}, // 5
    {0x1c, 0x30, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00}, // 6
    {0x7e, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    {0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00}, // 8
    {0x3c, 0x66, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00}, // 9
    // : (58) - @ (64)
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    {0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00}, // <
    {0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00}, // =
    {0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00}, // >
    {0x3c, 0x66, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x00}, // ?
    {0x3c, 0x66, 0x6e, 0x6a, 0x6e, 0x60, 0x3c, 0x00}, // @
    // A-Z (65-90)
    {0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x00}, // A
    {0x7c, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00}, // B
    {0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x00}, // C
    {0x78, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0x78, 0x00}, // D
    {0x7e, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x7e, 0x00}, // E
    {0x7e, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x00}, // F
    {0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00}, // G
    {0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00}, // H
    {0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00}, // I
    {0x3e, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 0x00}, // J
    {0x66, 0x6c, 0x78, 0x70, 0x78, 0x6c, 0x66, 0x00}, // K
    {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00}, // L
    {0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0x00}, // M
    {0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x66, 0x00}, // N
    {0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00}, // O
    {0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x00}, // P
    {0x3c, 0x66, 0x66, 0x66, 0x6a, 0x6c, 0x36, 0x00}, // Q
    {0x7c, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0x00}, // R
    {0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00}, // S
    {0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00}, // U
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00}, // V
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00}, // W
    {0x66, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x66, 0x00}, // X
    {0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00}, // Y
    {0x7e, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00}, // Z
    // [ (91) - ` (96)
    {0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00}, // [
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00}, // backslash
    {0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00}, // ]
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00}, // ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff}, // _
    {0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00}, // `
    // a-z (97-122)
    {0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00}, // a
    {0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x00}, // b
    {0x00, 0x00, 0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00}, // c
    {0x06, 0x06, 0x3e, 0x66, 0x66, 0x66, 0x3e, 0x00}, // d
    {0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00}, // e
    {0x1c, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x30, 0x00}, // f
    {0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x3c}, // g
    {0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00}, // h
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00}, // i
    {0x0c, 0x00, 0x1c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38}, // j
    {0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0x00}, // k
    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00}, // l
    {0x00, 0x00, 0xec, 0xfe, 0xd6, 0xc6, 0xc6, 0x00}, // m
    {0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    {0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00}, // o
    {0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60}, // p
    {0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06}, // q
    {0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00}, // r
    {0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00}, // s
    {0x30, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x1c, 0x00}, // t
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00}, // u
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00}, // v
    {0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xfe, 0x6c, 0x00}, // w
    {0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00}, // x
    {0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c}, // y
    {0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00}, // z
};

static int getFontIndex(char c)
{
    if (c >= 32 && c <= 122)
    {
        return c - 32;
    }
    return 0; // space for unknown chars
}

// Global state for callback
static std::string g_inputText;
static bool g_done = false;
static bool g_cancelled = false;
static size_t g_cursorPos = 0;

static void charCallback(GLFWwindow * /*window*/, unsigned int codepoint)
{
    if (codepoint >= 32 && codepoint < 127)
    {
        g_inputText.insert(g_cursorPos, 1, static_cast<char>(codepoint));
        g_cursorPos++;
    }
}

static void keyCallback(GLFWwindow *window, int key, int /*scancode*/, int action, int mods)
{
    if (action != GLFW_PRESS && action != GLFW_REPEAT)
        return;

    switch (key)
    {
    case GLFW_KEY_ENTER:
        if (!g_inputText.empty())
        {
            g_done = true;
        }
        break;
    case GLFW_KEY_ESCAPE:
        g_cancelled = true;
        break;
    case GLFW_KEY_BACKSPACE:
        if (g_cursorPos > 0)
        {
            g_inputText.erase(g_cursorPos - 1, 1);
            g_cursorPos--;
        }
        break;
    case GLFW_KEY_DELETE:
        if (g_cursorPos < g_inputText.length())
        {
            g_inputText.erase(g_cursorPos, 1);
        }
        break;
    case GLFW_KEY_LEFT:
        if (g_cursorPos > 0)
            g_cursorPos--;
        break;
    case GLFW_KEY_RIGHT:
        if (g_cursorPos < g_inputText.length())
            g_cursorPos++;
        break;
    case GLFW_KEY_HOME:
        g_cursorPos = 0;
        break;
    case GLFW_KEY_END:
        g_cursorPos = g_inputText.length();
        break;
    case GLFW_KEY_V:
        if (mods & GLFW_MOD_SUPER || mods & GLFW_MOD_CONTROL)
        {
            const char *clipboard = glfwGetClipboardString(window);
            if (clipboard)
            {
                std::string paste(clipboard);
                // Remove newlines and carriage returns from pasted text
                paste.erase(std::remove(paste.begin(), paste.end(), '\n'), paste.end());
                paste.erase(std::remove(paste.begin(), paste.end(), '\r'), paste.end());
                g_inputText.insert(g_cursorPos, paste);
                g_cursorPos += paste.length();
            }
        }
        break;
    }
}

// Simple immediate-mode text rendering using OpenGL 2.1
static void renderText(float x, float y, const std::string &text, float scale, float r, float g, float b)
{
    glColor3f(r, g, b);
    glPointSize(scale);

    for (size_t i = 0; i < text.length(); i++)
    {
        int fontIdx = getFontIndex(text[i]);
        const unsigned char *glyph = font8x8[fontIdx];

        glBegin(GL_POINTS);
        for (int row = 0; row < 8; row++)
        {
            for (int col = 0; col < 8; col++)
            {
                if (glyph[row] & (1 << (7 - col)))
                {
                    float px = x + (i * 8 + col) * scale;
                    float py = y - row * scale;
                    glVertex2f(px, py);
                }
            }
        }
        glEnd();
    }
}

std::optional<std::string> UrlPromptDialog::show(const std::string &defaultUrl)
{
    // Reset global state
    g_inputText = defaultUrl.empty() ? "rtsp://192.168.0.24:8554/cam" : defaultUrl;
    g_cursorPos = g_inputText.length();
    g_done = false;
    g_cancelled = false;

    if (!glfwInit())
    {
        std::cerr << "Failed to initialize GLFW for URL prompt" << std::endl;
        return std::nullopt;
    }

    // Use OpenGL 2.1 for simple immediate mode rendering
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    GLFWwindow *window = glfwCreateWindow(640, 200, "Enter RTSP URL", nullptr, nullptr);
    if (!window)
    {
        std::cerr << "Failed to create URL prompt window" << std::endl;
        glfwTerminate();
        return std::nullopt;
    }

    glfwMakeContextCurrent(window);
    glfwSwapInterval(1);

    glfwSetCharCallback(window, charCallback);
    glfwSetKeyCallback(window, keyCallback);

    // Set up orthographic projection
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, 640, 0, 200, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    double cursorBlinkTime = glfwGetTime();
    bool showCursor = true;

    while (!g_done && !g_cancelled && !glfwWindowShouldClose(window))
    {
        glfwPollEvents();

        // Cursor blinking
        double currentTime = glfwGetTime();
        if (currentTime - cursorBlinkTime > 0.5)
        {
            showCursor = !showCursor;
            cursorBlinkTime = currentTime;
        }

        // Clear
        glClearColor(0.1f, 0.1f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // Render title
        renderText(20, 170, "Enter RTSP URL:", 2.0f, 0.8f, 0.8f, 0.8f);

        // Render example
        renderText(20, 140, "Example: rtsp://192.168.0.24:8554/cam", 1.5f, 0.5f, 0.5f, 0.5f);

        // Input box background
        glColor3f(0.2f, 0.2f, 0.25f);
        glBegin(GL_QUADS);
        glVertex2f(15, 55);
        glVertex2f(625, 55);
        glVertex2f(625, 105);
        glVertex2f(15, 105);
        glEnd();

        // Input box border
        glColor3f(0.4f, 0.4f, 0.5f);
        glLineWidth(2.0f);
        glBegin(GL_LINE_LOOP);
        glVertex2f(15, 55);
        glVertex2f(625, 55);
        glVertex2f(625, 105);
        glVertex2f(15, 105);
        glEnd();

        // Render input text
        float textScale = 2.0f;
        float textX = 25;
        float textY = 90;

        // Calculate visible portion of text (scrolling)
        size_t maxVisibleChars = 70;
        size_t startIdx = 0;
        if (g_cursorPos > maxVisibleChars - 5)
        {
            startIdx = g_cursorPos - maxVisibleChars + 5;
        }
        std::string visibleText = g_inputText.substr(startIdx, maxVisibleChars);

        renderText(textX, textY, visibleText, textScale, 1.0f, 1.0f, 1.0f);

        // Render cursor
        if (showCursor)
        {
            size_t cursorVisualPos = g_cursorPos - startIdx;
            float cursorX = textX + cursorVisualPos * 8 * textScale;
            glColor3f(1.0f, 1.0f, 1.0f);
            glLineWidth(2.0f);
            glBegin(GL_LINES);
            glVertex2f(cursorX, textY - 16);
            glVertex2f(cursorX, textY + 4);
            glEnd();
        }

        // Render instructions
        renderText(20, 30, "Press ENTER to connect, ESC to cancel", 1.5f, 0.5f, 0.5f, 0.5f);

        glfwSwapBuffers(window);
    }

    glfwDestroyWindow(window);
    glfwTerminate();

    if (g_cancelled || g_inputText.empty())
    {
        return std::nullopt;
    }

    return g_inputText;
}
